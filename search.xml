<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股文备份</title>
      <link href="2021/05/17/%E5%85%AB%E8%82%A1%E6%96%87%E5%A4%87%E4%BB%BD/"/>
      <url>2021/05/17/%E5%85%AB%E8%82%A1%E6%96%87%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>备份一下去年面试时用到的八股文和小部分面经。</p><a id="more"></a><h2 id="面经总结"><a href="#面经总结" class="headerlink" title="面经总结"></a>面经总结</h2><blockquote><p> <a href="https://www.nowcoder.com/discuss/438311?type=2&channel=1003&source_id=discuss_terminal_discuss_jinghua" target="_blank" rel="noopener">vivo面经汇总</a></p><p><a href="https://www.nowcoder.com/discuss/439647?type=0&order=7&pos=19&page=1&channel=2000&source_id=discuss_center_0" target="_blank" rel="noopener">JVM、集合、并发知识点</a></p></blockquote><p>###8.13 拼多多服务端</p><h4 id="不会的（会的都想不起来了"><a href="#不会的（会的都想不起来了" class="headerlink" title="不会的（会的都想不起来了"></a>不会的（会的都想不起来了</h4><ol><li>GC Stop The World条件 // 深入理解Java虚拟机中有解</li><li>JDK1.8和1.7方法区的不同</li><li>Redis架构模式</li><li>Redis五种数据结构的底层</li><li>Redis淘汰策略（具体怎么选key）</li><li>Nginx反向代理分配方式</li><li>AOP具体实现（只说到反向代理不够）</li><li>Mybatis ${}和#{}</li></ol><h4 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h4><p>给一个数n，若是偶数则n/2，若是奇数则n-1或n+1，求最少几步能达到n=1？（递归）怎么优化？</p><h3 id="8-15-拼多多服务端II"><a href="#8-15-拼多多服务端II" class="headerlink" title="8.15 拼多多服务端II"></a>8.15 拼多多服务端II</h3><ol><li>论文介绍一下</li><li>怎么防止过拟合</li><li>为什么转开发？</li><li>Java最新版本是多少？</li><li>怎么理解Java虚拟机？</li><li>JVM是怎么垃圾回收的？<ul><li>GC Roots有哪些？</li><li>介绍一下G1？（不太清楚）那就CMS</li></ul></li><li>说一下synchronized原理</li><li>说一下concurrentHashMap<ul><li>1.8的优化？</li><li>说一下CAS？</li><li>说一下红黑树？为什么不用平衡二叉树？</li></ul></li><li>新建线程池参数？有哪些阻塞队列？<ul><li>用ArrayBlockingQueue和LinkedBlockingQueue有什么区别？（没太懂）假设corePoolSize=5, maximum=10, 100个线程往里面塞</li></ul></li></ol><h4 id="手撕-1"><a href="#手撕-1" class="headerlink" title="手撕"></a>手撕</h4><p>二叉查找树的查找和插入</p><p>说一下删除的思路？</p><p>如果树里面放的不是int而是自定义类，怎么进行排序？（重写compareTo）怎么保证重写？（实现comparable接口）</p><p>你这里面用到了==，说一下两个Integer用==是什么效果？</p><p>####最后</p><p>你对拼多多的了解？你觉得拼多多在服务端上有哪些挑战？</p><h3 id="9-1-拼多多客户端"><a href="#9-1-拼多多客户端" class="headerlink" title="9.1 拼多多客户端"></a>9.1 拼多多客户端</h3><p>杂七杂八问了一堆，不会的主要有四个：</p><ol><li>什么是中间人攻击？</li><li>怎么理解UTF-8？</li><li>翻墙翻着翻着用不了了是为什么？（我说代理服务器也被墙了，但是感觉太简单了……</li><li>手撕生产者消费者，改了半天也没改好</li></ol><h4 id="手撕-2"><a href="#手撕-2" class="headerlink" title="手撕"></a>手撕</h4><p>一个字符串，分割出所有单词。单词的定义：全是数字/全是字母/字母开头+数字。</p><h3 id="8-30-远景-30min"><a href="#8-30-远景-30min" class="headerlink" title="8.30 远景 30min"></a>8.30 远景 30min</h3><ol><li>项目</li><li>Redis五种数据结构（跳表实现）</li><li>Redis为什么单线程？IO多路复用讲一下</li><li>mysql非聚簇索引IO次数</li><li>性别为什么不加索引</li></ol><h4 id="手撕-3"><a href="#手撕-3" class="headerlink" title="手撕"></a>手撕</h4><p>股票一次买卖/k次买卖 </p><h3 id="9-2-远景II-15min-WDNMD现场比电话还短"><a href="#9-2-远景II-15min-WDNMD现场比电话还短" class="headerlink" title="9.2 远景II 15min (WDNMD现场比电话还短)"></a>9.2 远景II 15min (WDNMD现场比电话还短)</h3><p>三个不会的：</p><ol><li>生产环境频繁fullGC怎么紧急解决</li><li>堆内内存和堆外内存</li><li>100亿手机号100m内存求去重后数量</li></ol><h3 id="9-1-BIGO-45min"><a href="#9-1-BIGO-45min" class="headerlink" title="9.1 BIGO 45min"></a>9.1 BIGO 45min</h3><ol><li>项目</li><li>Redis锁，顺便写了一下</li><li>AOP</li><li>JavaGC</li><li>设计模式了解吗？写一下单例模式</li><li>尬聊15分钟（原来Java用的最少，怪不得不知道问啥。面试官表达了BIGO在广州除了微信以外的强无敌</li></ol><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><ol><li><p><strong>三数之和</strong>：给定一个包含$n$个整数的数组$nums$，求其中和为k的三元组。</p></li><li><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/" target="_blank" rel="noopener"><strong>圆圈中最后剩下的</strong>（难）</a>：</p></li><li><p><a href="https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode/" target="_blank" rel="noopener"><strong>每日温度</strong></a>：给一个长度为$n$的数组，求数组中每个数最先比该数大的index。若不存在，则为0。</p><p>(1) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># temperature = [len=n]</span></span><br><span class="line">next = [max]*<span class="number">102</span>  <span class="comment"># 一个数组，其中存放着温度0-102的index</span></span><br><span class="line">res = [<span class="number">0</span>]*n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):  <span class="comment">#逆序求解</span></span><br><span class="line">minindex = min(next[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(temperature[i],<span class="number">102</span>)</span><br><span class="line"><span class="keyword">if</span> minindex&lt;max:</span><br><span class="line">res = minindex-i</span><br><span class="line">next[temperature[i]]=i</span><br></pre></td></tr></table></figure><p>(2) 用栈</p></li><li><p>两个正序数组的中位数</p></li><li><p>完全背包</p></li><li><p>求所有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; trace;</span><br><span class="line">    <span class="keyword">static</span> Set&lt;Integer&gt; searched = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Set&lt;List&lt;Integer&gt;&gt; allCircles = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] e = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (searched.contains(i))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            trace = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            findCycle(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : allCircles)</span><br><span class="line">            System.out.println(<span class="string">"circle: "</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findCycle</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span>[][] e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = trace.indexOf(v);</span><br><span class="line">        <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; circle = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (j &lt; trace.size()) &#123;</span><br><span class="line">                circle.add(trace.get(j));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(circle);</span><br><span class="line">            allCircles.add(circle);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        trace.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[v][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                searched.add(i);</span><br><span class="line">                findCycle(i, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        trace.remove(trace.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p><a href="https://elsef.com/2020/02/29/%E4%B8%80%E4%B8%AATCP%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">TCP的发送与接收缓冲区</a></p><h3 id="TCP接收端窗口一直为0时如何处理？"><a href="#TCP接收端窗口一直为0时如何处理？" class="headerlink" title="TCP接收端窗口一直为0时如何处理？"></a>TCP接收端窗口一直为0时如何处理？</h3><p>在回答这个问题之前，先问一个问题，通信双方的客户端与服务器是AI机器人哇？不是！那是什么？是两个不够智能的僵硬机器，根据人类的指令输入来完成通信。</p><p>通信过程繁复兀杂，但拨开云雾会发现，其实通信过程可以分为两大类：</p><p>*<em>1）事件触发（event trigger)  简称ET<br>2）定时器触发 （ timer trigger) 简称 TT<br>*</em><br>我们以一个例子（TCP建立连接的三次握手）来说明两者的区别：</p><p>1.1 事件触发<br>A主动发起对B的TCP连接（SYN），这是ET还是TT呢？ 是ET，因为是位于A后的老王发出的指令，比如在浏览器里输入B 的网址，然后触发TCP连接</p><p>1.2 定时器触发<br>但是如果SYN在发给B 的过程中丢了呢？是否还需要老王再次提交指令？如果是，那这个TCP协议栈就太不友好了，事实上商用的TCP会缓存用户的连接指令，并启动一个重传定时器，定时器超时，无需老王的干预，TCP会自动重传连接指令，这就是定时器触发</p><p>2.1 事件触发<br>假设B接收到A的连接请求，这个就是事件触发，是由于外部事件而触发的动作，动作是什么呢？ 发SYN + ACK。</p><p>2.2 定时器触发<br>B同样担心自己的SYN + ACK丢失，所以也会启动一个重传定时器，如果在超时时间内没有接收到A的ACK，则会触发重传动作，如果收到ACK，则关闭定时器。</p><p>3 事件触发<br>假设A接收到B的SYN + ACK，这是一个外部事件触发的动作，动作是<br>1）关闭重传定时器<br>2）发送ACK<br>3）将TCP状态更新为established</p><p>对于3.2里的ACK要不要启动重传定时器？不需要，如果是，会无限循环到永远。</p><p>以上通过3-way 握手解释了事件触发以及定时器触发的区别，对于题主的问题就非常好回答了。</p><p>对于应用层提交给TCP的数据（事件触发），触发的动作是<br>1）发送数据 并缓冲数据<br>2）为数据启动重传定时器</p><p>如果接到对方ACK，事件触发的动作是<br>1）关闭定时器<br>2）释放缓存</p><p>如果定时器超时也没有接收到ACK，则定时器触发，动作是<br>1）重传数据<br>2）记录重传次数</p><p>如果重传次数满，比如重传8次，则是事件触发，动作是<br>1）reset 或关闭TCP连接<br>2）通知应用层出错</p><p>再来回答第二个问题，B告诉A，window size =0，则A认为这是一个外部事件，触发一个动作<br>1）启动探测定时器（ persistent timer)</p><p>如果在PT超时之前接收到B的window &gt;0, 则事件触发，动作为<br>1）关闭PT<br>2）有数据则继续发送数据<br>3）更新自己的滑动窗口右侧</p><p>如果在PT超时之前没有接收到B window更新，则定时器触发，动作为<br>1）发送一个byte 合法数据（滑动窗口内）或非法数据（滑动窗口外）<br>2）刷新定时器<br>3）记录超时次数</p><p>如果超时次数到达极限，则事件触发，动作为<br>1）reset 或关闭TCP连接<br>2）通知应用层出错原因</p><p>总结<br>整个通信过程<strong>只需要一次用户输入（用户事件），接下来的通信过程全部依赖事件触发、定时器触发而产生的动作自动完成</strong>，或如行云流水（顺利）或磕磕绊绊（不顺利），但无需用户干预。</p><h2 id="HTTP-HTTPS协议"><a href="#HTTP-HTTPS协议" class="headerlink" title="HTTP/HTTPS协议"></a>HTTP/HTTPS协议</h2><h3 id="GET和POST方法"><a href="#GET和POST方法" class="headerlink" title="GET和POST方法"></a>GET和POST方法</h3><p>####GET</p><p>传递参数长度受限制，因为传递的参数是直接表示在地址栏中，而特定浏览器和服务器对url的长度是有限制的。</p><p><strong>GET请求也可以通过body传送数据，但不规范</strong></p><p>因此，GET不适合用来传递私密数据，也不适合拿来传递大量数据。</p><p>一般的HTTP请求大多都是GET。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST把传递的数据封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，对数据量没有限制，也不会显示在URL中。</p><p>表单的提交用的是POST。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th align="left"></th><th align="left">GET</th><th align="left">POST</th></tr></thead><tbody><tr><td align="left">后退按钮/刷新</td><td align="left">无害</td><td align="left">数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td align="left">书签</td><td align="left">可收藏为书签</td><td align="left">不可收藏为书签</td></tr><tr><td align="left">缓存</td><td align="left">能被缓存</td><td align="left">不能缓存</td></tr><tr><td align="left">编码类型</td><td align="left">application/x-www-form-urlencoded</td><td align="left">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td align="left">历史</td><td align="left">参数保留在浏览器历史中。</td><td align="left">参数不会保存在浏览器历史中。</td></tr><tr><td align="left">对数据长度的限制</td><td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td align="left">无限制。</td></tr><tr><td align="left">对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td align="left">没有限制。也允许二进制数据。</td></tr><tr><td align="left">安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td align="left">POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td align="left">可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td align="left">数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="Accept与Content-Type的区别"><a href="#Accept与Content-Type的区别" class="headerlink" title="Accept与Content-Type的区别"></a>Accept与Content-Type的区别</h3><p>1.Accept属于请求头， Content-Type属于实体头。</p><blockquote><p>实体头部：出现的作用主要是对Entity的一些信息进行描述。通用首部并非对实体进行描述。</p></blockquote><p>Http报头分为通用报头，请求报头，响应报头和实体报头。<br>请求方的http报头结构：通用报头|请求报头|实体报头<br>响应方的http报头结构：通用报头|响应报头|实体报头</p><p>2.Accept代表发送端（客户端）希望接受的数据类型。<br>比如：Accept：text/xml;<br>代表客户端希望接受的数据类型是xml类型</p><p>Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。<br>比如：Content-Type：text/html;<br>代表发送端发送的数据格式是html。</p><p>二者合起来，<br>Accept:text/xml；<br>Content-Type:text/html<br>即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。</p><h3 id="HTTPS为什么使用混合加密？"><a href="#HTTPS为什么使用混合加密？" class="headerlink" title="HTTPS为什么使用混合加密？"></a>HTTPS为什么使用混合加密？</h3><p>对称加密（共享密钥）存在的问题是：客户端和服务器需得到同一把公钥，但如何将公钥安全的共享是个问题。发送密钥就有被窃听的风险，但不发送对方就无法解密；密钥若能安全发送，数据也应该能够安全发送，密钥的存在又没有了意义。</p><p><strong><em>解决方案：非对称加密（RSA算法）</em></strong></p><p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p><p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进 行加密处理，对方收到被加密的信息后，再使用自己的私有密钥 进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><p>但现在还是存在问题：<strong>如何证明公钥的正确性？</strong></p><p><strong><em>解决方案：公开密钥证书</em></strong></p><p>![image-20200818162915657](/Users/silverlining/Library/Application Support/typora-user-images/image-20200818162915657.png)</p><p><strong>HTTPS 比 HTTP 要慢 2 到 100 倍</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/8525388-f4425aaa05ea3097.png" alt="img"></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="URL解析过程"><a href="#URL解析过程" class="headerlink" title="URL解析过程"></a>URL解析过程</h3><ol><li>浏览器根据域名解析IP地址（浏览器缓存、系统缓存、路由器缓存、ISP缓存）</li><li>浏览器与web服务器建立TCP连接</li><li>浏览器给web服务器发送HTTP请求</li><li>服务端响应HTTP请求，浏览器得到HTML代码</li><li>浏览器解析HTML代码，并根据HTML代码请求资源</li><li>关闭TCP连接，浏览器对页面进行渲染</li></ol><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ol><li><p>cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；</p></li><li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；</p></li><li><p>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；</p></li></ol><h3 id="什么是servlet？"><a href="#什么是servlet？" class="headerlink" title="什么是servlet？"></a>什么是servlet？</h3><blockquote><p><a href="https://stackoverflow.com/questions/7213541/what-is-java-servlet" target="_blank" rel="noopener">A servlet</a> is simply a class which responds to a particular type of network request - most commonly an HTTP request. Basically servlets are usually used to implement web applications - but there are also various frameworks which operate on top of servlets (e.g. Struts) to give a higher-level abstraction than the “here’s an HTTP request, write to this HTTP response” level which servlets provide.</p><p>Servlets run in a <em>servlet container</em> which handles the networking side (e.g. parsing an HTTP request, connection handling etc). One of the best-known open source servlet containers is <a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Tomcat</a>.</p></blockquote><p>简单理解：servlet就是一套用来处理(HTTP) request和返回respond的规范接口。servlet运行在servlet容器里，如Tomcat。Servlet容器也叫做Servlet引擎，是Web服务器或应用程序服务器的一部分，用于在发送的请求和响应之上提供网络服务。</p><h3 id="子网掩码-IP地址-网关"><a href="#子网掩码-IP地址-网关" class="headerlink" title="子网掩码-IP地址-网关"></a>子网掩码-IP地址-网关</h3><blockquote><p><a href="https://www.cnblogs.com/JuneWang/p/3917697.html" target="_blank" rel="noopener">IP地址，子网掩码，默认网关，DNS服务器详解</a></p><p><a href="https://www.zhihu.com/question/23403263/answer/25808408" target="_blank" rel="noopener">默认网关有什么用？</a></p><p><a href="https://www.zhihu.com/question/29723388" target="_blank" rel="noopener">子网掩码与IP地址有关系吗？</a></p></blockquote><p><strong>简单的来说</strong>，子网掩码通过和IP地址取<code>&amp;</code>来判断两个ip地址是否处于同一网络；网关则是一个网络通向其他网络地址的大门。</p><hr><p>设A：10.1.1.10 /24</p><p>​    B：10.1.1.20 /24</p><p>​    C：50.1.1.80 /24</p><p>AB在同一局域网，C位于外网。</p><p>三个表：</p><p>ARP表：主机维护，存放IP地址和MAC地址对应关系。</p><p>MAC地址表：交换机维护，存放MAC地址和交换机端口对应关系。</p><p>路由表：路由器维护，存放IP地址和路由器端口对应关系。</p><p>首先AB通信，例如A要给B发送一个数据包，目前A知道B的IP地址，根据掩码规则判定B和自己在同一个局域网，同一个广播域。接下来A通过广播方式获取B的MAC地址，添加到自己的ARP表中。然后把要发送的包封装，然后发送给交换机，交换机收到数据包后解封装得到B的MAC地址，根据MAC地址表转发到B所连接的交换机端口，完成发送。</p><p>如果A要和C通信，发送一个包给C的话，也只知道C的IP地址，然后A根据掩码规则发现C和自己不是同一个局域网的，广播不到C，所以A只能把数据包发给网关，由网关发出去给到C。A同样通过广播方式获取网关的MAC地址，然后把C的IP地址和网关的MAC地址封装到数据包后发给交换机，交换机解封装后对比MAC地址表，发现是发给网关的包，就转发到网关即路由器所在的交换机端口。路由器收到包之后再解封装，得到C的IP地址，然后根据自己的路由表转发到相应的端口。完成通信。</p><p>所以如果计算机上不设置子网掩码，从第一步就不能完成，下面就更不能继续了。</p><p>如果同一个<strong>广播域</strong>里有机器设置不同的子网掩码，依然能够通信，只不过有的内网包需要到网关绕一圈。外网包的话只要网关设置对了就没问题。</p><p>####一道题</p><p>某路由器的路由表如下表所示：</p><table><thead><tr><th>目的网络</th><th>下一跳</th><th>接口</th></tr></thead><tbody><tr><td>170.96.40.0/23</td><td>196.1.1.1</td><td>S1</td></tr><tr><td>170.96.40.0/25</td><td>196.2.2.2</td><td>S2</td></tr><tr><td>170.96.40.0/27</td><td>196.3.3.3</td><td>S3</td></tr><tr><td>0.0.0.0/0</td><td>196.5.5.5</td><td>S4</td></tr></tbody></table><p>若路由器收到一个目的地址为170.96.40.33的IP分组，则转发该IP分组的接口是：</p><ul><li><input disabled type="checkbox"> S1</li><li><input checked disabled type="checkbox"> S2</li><li><input disabled type="checkbox"> S3</li><li><input disabled type="checkbox"> S4</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h2 id="进程通信的方法"><a href="#进程通信的方法" class="headerlink" title="进程通信的方法"></a><a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">进程通信的方法</a></h2><ol><li>管道 (ps -ef <strong>|</strong> grep mysql)</li><li>有名管道</li><li>信号 (Ctrl+C, kill -9)</li><li>消息队列</li><li>共享内存</li><li>信号量 (常用于共享内存的同步)</li><li>socket (网络通信)</li></ol><h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><ul><li>临界区</li><li>互斥量</li><li>信号量</li><li>事件</li></ul><p><a href="https://www.zhihu.com/question/39850927" target="_blank" rel="noopener"><strong>关系</strong></a>：互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。</p><p>信号量（semaphore）是一种更高级的同步机制，mutex可以说是semaphore在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p><h2 id="多进程VS多线程"><a href="#多进程VS多线程" class="headerlink" title="多进程VS多线程"></a>多进程VS多线程</h2><blockquote><p><a href="https://www.nowcoder.com/discuss/450511?type=1&channel=1008&source_id=discuss_center_discuss_hot" target="_blank" rel="noopener">进程、线程基础知识全家桶</a></p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h3><ul><li><input checked disabled type="checkbox"> <p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><input checked disabled type="checkbox"> <p>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><input checked disabled type="checkbox"> <p>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><input checked disabled type="checkbox"> <p>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链。</p></li></ul><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><ul><li><input disabled type="checkbox"> 打破互斥条件。即允许进程同时访问某些资源。(Meaningless)</li><li><input disabled type="checkbox"> 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。</li><li><input checked disabled type="checkbox"> 打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。</li><li><input checked disabled type="checkbox"> <strong>打破循环等待条件，实行资源有序分配策略</strong>。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。</li></ul><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a><a href="https://juejin.im/post/6844903905483030536#comment" target="_blank" rel="noopener">反射</a></h2><blockquote><p> 反射机制是<strong><em>在运行时</em></strong>，<strong>对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。</strong>在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。这种<strong>动态获取的信息以及动态调用对象的方法的功能</strong>称为Java语言的反射机制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(<span class="string">"com.eft.reflect.Apple"</span>);</span><br><span class="line">Method method = clz.getMethod(<span class="string">"setPrice"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br><span class="line">method.invoke(object, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="通过反射创建类对象"><a href="#通过反射创建类对象" class="headerlink" title="通过反射创建类对象"></a>通过反射创建类对象</h3><h4 id="获得对象所属类"><a href="#获得对象所属类" class="headerlink" title="获得对象所属类"></a>获得对象所属类</h4><h5 id="类-class"><a href="#类-class" class="headerlink" title="类.class"></a><code>类.class</code></h5><h5 id="实例对象-getClass"><a href="#实例对象-getClass" class="headerlink" title="实例对象.getClass()"></a><code>实例对象.getClass()</code></h5><h5 id="Class-forName-className"><a href="#Class-forName-className" class="headerlink" title="Class.forName(className)"></a><code>Class.forName(className)</code></h5><p>内部实际调用的是<code>Class.forName(className, true, classLoader)</code>。第二个boolean表示是否初始化。</p><h5 id="ClassLoader-loadClass-className"><a href="#ClassLoader-loadClass-className" class="headerlink" title="ClassLoader.loadClass(className)"></a><code>ClassLoader.loadClass(className)</code></h5><p>实际上是<code>ClassLoader.loadClass(className,false)</code>。 false代表目标对象不执行连接（验证、准备、解析），也就没有进行初始化。</p><p>在 Spring IOC 中，在资源加载器获取要读入的字节的时候，即读取一些 Bean 的配置的时候，如果是以 classpath 的方式来加载，就需要使用 ClassLoader 的 loadClass() 方法来加载。之所以这样做，是和 Spring IOC 的 Lazy Loading 有关，即延迟加载。Spring IOC 为了加快初始化的速度，大量的使用了延迟加载技术，而使用 ClassLoader 的 loadClass() 方法不需要执行类加载过程中的链接和初始化的步骤，这样做能有效的加快加载速度，把类的初始化工作留到实际使用到这个类的时候才去执行。</p><h5 id="getClass-和forName-得到的是相同的还是不同的Class实例？"><a href="#getClass-和forName-得到的是相同的还是不同的Class实例？" class="headerlink" title="getClass()和forName()得到的是相同的还是不同的Class实例？"></a><code>getClass()</code>和<code>forName()</code>得到的是相同的还是不同的Class实例？</h5><p>只要被同一个类加载器所加载，便是同一个Class实例。</p><h4 id="通过Class对象的newInstance-方法"><a href="#通过Class对象的newInstance-方法" class="headerlink" title="通过Class对象的newInstance()方法"></a>通过Class对象的<code>newInstance()</code>方法</h4><p><code>public T newInstance()</code></p><ul><li>要求被调用的构造函数是可见，否则会抛出IllegalAccessException xxx can not access a member of class eft.reflex.Singleton with modifiers “private”的异常</li><li>只能够调用无参的构造函数，即默认的构造函数</li></ul><p>####通过Constructor对象的<code>newInstance()</code>方法</p><ul><li><p><strong><code>public Constructor&lt;?&gt;[] getConstructors()</code> //获取类对象的所有可见的构造函数</strong></p></li><li><p><strong><code>public Constructor&lt;?&gt;[] getDeclaredConstructors()</code>//获取类对象的所有的构造函数</strong></p></li><li><p><strong><code>public Constructor getConstructor(Class&lt;?&gt;... parameterTypes)</code></strong></p><ul><li>获取指定的可见的构造函数，参数为：指定构造函数的参数类型数组</li><li>如果该构造函数不可见或不存在，会抛出 NoSuchMethodException 异常</li></ul></li><li><p><strong><code>public Constructor getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></strong></p><ul><li>获取指定的构造函数，参数为：指定构造函数的参数类型数组</li><li>无论构造函数可见性如何，均可获取</li></ul></li></ul><h2 id="TODO-I-O多路复用"><a href="#TODO-I-O多路复用" class="headerlink" title="(TODO) I/O多路复用"></a>(TODO) I/O多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h3 id="epoll-红黑树"><a href="#epoll-红黑树" class="headerlink" title="epoll(红黑树)"></a>epoll(红黑树)</h3><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol><li><p>候选键：唯一确定行的最小子集（若非最小则为超键）</p></li><li><p>全键：由所有属性构成的主键（不能为空）</p></li><li><p>外键：其他表的主键</p><p>![image-20200706172046829](/Users/silverlining/Library/Application Support/typora-user-images/image-20200706172046829.png)</p></li><li><p>关系代数基本操作：</p><blockquote><p>$\sigma$ 选择, $\pi$ 投影, $\cup$ 并, $-$ 差, $\times$ 笛卡尔乘积</p></blockquote></li><li><p>JOIN 笛卡尔乘积</p></li><li><p>OUTER JOIN 外连接</p></li><li><p>OUTER UNION 外并</p></li><li><p>基表&lt;–&gt;视图(view)   NULL UNIQUE DEFAULT CHECK(定义约束条件)</p></li><li><p>基本结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] target-<span class="keyword">list</span></span><br><span class="line"><span class="keyword">FROM</span> relation-<span class="keyword">list</span></span><br><span class="line"><span class="keyword">WHERE</span> qualification</span><br><span class="line">(<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">grouping</span>-<span class="keyword">list</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">group</span>-qualification) <span class="comment">-- 对组的筛选</span></span><br></pre></td></tr></table></figure></li><li><p>若无条件连接则连接为笛卡尔乘积。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S,Reserves R <span class="comment">-- 此处为笛卡尔乘积</span></span><br><span class="line"><span class="keyword">WHERE</span> S.sid=R.sid <span class="keyword">AND</span> R.bid=<span class="number">103</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.sname</span><br><span class="line"><span class="keyword">FROM</span> Sailors S, Boats B, Reserves R</span><br><span class="line"><span class="keyword">WHERE</span> S.sid=R.sid <span class="keyword">AND</span> R.sid=B.sid <span class="keyword">AND</span> B.color=<span class="string">'red'</span></span><br><span class="line"><span class="keyword">INTERSECT</span> <span class="comment">-- 交(mysql不支持)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 嵌套查询</span></span><br><span class="line"><span class="keyword">SELECT</span> S.name</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.sid <span class="keyword">IN</span>(<span class="keyword">NOT</span> <span class="keyword">IN</span>) (<span class="keyword">SELECT</span> R.sid <span class="keyword">FROM</span> Reserves R <span class="keyword">WHERE</span> R.bid=<span class="number">103</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- EXISTS</span></span><br><span class="line"><span class="keyword">SELECT</span> S.name</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Reserves R <span class="keyword">WHERE</span> R.bid=<span class="number">103</span> <span class="keyword">AND</span> S.sid=R.sid)</span><br></pre></td></tr></table></figure></li><li><blockquote><p>如何找到只预定了boat#103一次的水手？</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- TODO</span></span><br><span class="line"><span class="keyword">SELECT</span> S.name</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Reserves R1, Reserves R2 </span><br><span class="line">                  <span class="keyword">WHERE</span> R1.sid=R2.sid <span class="keyword">AND</span> R1.bid=<span class="number">103</span> </span><br><span class="line">                  <span class="keyword">AND</span> R2.bid=<span class="number">103</span> <span class="keyword">AND</span> R1.day &lt;&gt; R2.day)</span><br></pre></td></tr></table></figure></li><li><p><strong>相关子查询</strong></p><blockquote><p>子查询的查询条件依赖于父查询</p></blockquote><p>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表；</p><p>然后再取外层表的下一个元组；</p><p>重复这一过程，直至外层表全部检查完为止。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- eg:查询只被一个水手预定过的船</span></span><br><span class="line"><span class="keyword">SELECT</span> bid</span><br><span class="line"><span class="keyword">FROM</span> Reserves R1</span><br><span class="line"><span class="keyword">WHERE</span> bid <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="keyword">SELECT</span> bid</span><br><span class="line">                <span class="keyword">FROM</span> Reserves R2</span><br><span class="line">                <span class="keyword">WHERE</span> R2.sid&lt;&gt;R1.sid)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ANY</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.rating &gt; <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> S2.rating <span class="keyword">FROM</span> Sailors S2 </span><br><span class="line">                     <span class="keyword">WHERE</span> S2.sname=<span class="string">'Horatio'</span>)</span><br></pre></td></tr></table></figure></li><li><blockquote><p>聚合查询</p></blockquote><p>COUNT(*) / COUNT([DISTINCT]A) / SUM([DISTINCT]A) / AVG([DISTINCT]A) / MAX(A) / MIN(A)</p></li><li><p>GROUP BY / HAVING</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.rating, <span class="keyword">MIN</span>(S.age) <span class="keyword">AS</span> minage</span><br><span class="line"><span class="keyword">FROM</span> Sailors S</span><br><span class="line"><span class="keyword">WHERE</span> S.age &gt;= <span class="number">18</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S.rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*)&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><blockquote><h1 id="【原创】惊！史上最全的select加锁分析-Mysql"><a href="#【原创】惊！史上最全的select加锁分析-Mysql" class="headerlink" title="【原创】惊！史上最全的select加锁分析(Mysql)"></a><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">【原创】惊！史上最全的select加锁分析(Mysql)</a></h1></blockquote><h3 id="事物隔离级别-MVCC"><a href="#事物隔离级别-MVCC" class="headerlink" title="事物隔离级别 MVCC"></a><a href="https://juejin.im/post/5c9b1b7df265da60e21c0b57#comment" target="_blank" rel="noopener">事物隔离级别 MVCC</a></h3><p>四个事物隔离级别<strong><em>未提交读、已提交读、可重复度、可串行化</em></strong>中</p><p>已提交读和可重复度通过MVCC(多版本并发控制)实现。</p><p>重点属性：</p><p><strong><code>tr x_id</code></strong> 生成该条记录的事物id</p><p><strong><code>roll pointer</code></strong> 指向上一个版本数据的指针，相当于版本链。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169bf198532476f5?imageslim" alt="img"></p><p>SELECT之前生成一个ReadView，其中记录所有目前仍活跃的事物id，将当前事物id与ReadView中id做对比，若在ReadView中，说明目前该事物仍活跃，无法读取该版本记录，则顺着roll_pointer向前寻找。</p><p><strong>已提交读：在每次SELECT之前生成一个ReadView</strong></p><p><strong>可重复读：在第一次SELECT之前生成ReadView</strong></p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p> InnoDB、MyISAM: MyISAM只缓存索引，不缓存真实数据；InnoDB都缓存，对内存要求较高/外键、事物、行级锁</p><p>阿里XtraDB：高并发高负载</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ol start="2"><li><p>索引：单值索引、复合索引</p></li><li><p><strong>什么是索引？</strong></p><p>帮助MySQL高效获取数据的<u>数据结构</u>。 （查找、排序）</p></li><li><p>索引问题：</p><ul><li><p>索引往往存储在磁盘上</p></li><li><p>频繁增删的字段不适合建索引</p></li><li><p>索引优势：提高数据检索效率，降低数据库IO成本</p></li><li><p>索引劣势：占用空间、降低更新表的速度</p></li><li><p>单值索引、 唯一索引 (UNIQUE KEY)、 复合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> mytable <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName</span><br></pre></td></tr></table></figure></li><li><p>索引类型：B+Tree索引、Hash索引、Full-text全文索引、R-Tree索引</p></li><li><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之 上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p></li><li><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段创建索引</li><li>外键建立索引</li><li>排序字段建立索引</li><li>group by建立索引</li><li>表中记录过少不建立索引</li></ol></li></ul><ol start="7"><li><p>频繁增删的字段不建立索引</p><ol start="8"><li>重复且平均的数值不建立索引</li></ol></li></ol></li></ol><ol start="6"><li><p>limit的效率问题</p><p>在offset很大的时候，使用limit会出现效率问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from test where val=4 limit 300000,5;</span><br><span class="line">-- 5 rows in set (15.98 sec)</span><br><span class="line">select * from test a inner join (select id from test where val=4 limit 300000,5) b on a.id=b.id;</span><br><span class="line">-- 5 rows in set (0.38 sec)</span><br></pre></td></tr></table></figure><p>原因：limit查询的过程：查询到索引叶子结点上的数据，然后在根据叶子节点上的PRIMARY KEY去聚簇索引上查找全部字段。查找前300005个，抛弃前300000个。</p><p>解决方法：先使用limit查出主键id</p></li><li><p>Q：非聚簇索引的查询一定需要回表查询（二次查询）吗？</p><p>A：非也。在覆盖索引(一个查询语句的执行只用从索引中就能取得)的情况下只需查询一次。</p></li><li><p>联合索引在B+树中的结构</p><p><img src="https://www.2cto.com/uploadfile/Collfiles/20180217/20180217145611186.png" alt="img"></p><p>非叶子节点存的是第一个关键字的索引，叶节点存的是联合索引的数据。</p></li><li><p>MySQL5.6的优化：索引下推 index condition</p><ul><li>在不使用ICP的情况下，在使用<strong>非主键索引（又叫普通索引或者二级索引）</strong>进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</li><li>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</li></ul><p>![image-20200730213728003](/Users/silverlining/Library/Application Support/typora-user-images/image-20200730213728003.png)</p><p>![image-20200730213739307](/Users/silverlining/Library/Application Support/typora-user-images/image-20200730213739307.png)</p></li></ol><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ol><li>当Master节点进行insert、update、delete操作时，会按顺序写入到binlog中；</li><li>slave从库连接master主库，Master有多少个slave就会创建多少个binlog dump线程。</li><li>当Master节点的binlog发生变化时，binlog dump 线程会通知所有的slave节点，并将相应的binlog内容推送给slave节点。</li><li>I/O线程接收到 binlog 内容后，将内容写入到本地的 relay-log。</li><li>SQL线程读取I/O线程写入的relay-log，并且根据 relay-log 的内容对从数据库做对应的操作。</li></ol><p><img src="https://pic2.zhimg.com/v2-de44ec1348280cd6c709ffde0c109b79_b.png" alt="img"></p><h3 id="BinLog"><a href="#BinLog" class="headerlink" title="BinLog"></a>BinLog</h3><p>二进制日志包含了<strong>引起或可能引起数据库改变</strong>(如delete语句但没有匹配行)的事件信息，但绝不会包括select和show这样的查询语句。语句以”事件”的形式保存，所以包含了时间、事件开始和结束位置等信息。</p><p>二进制日志是<strong>以事件形式记录的，不是事务日志(但可能是基于事务来记录二进制日志)</strong>，不代表它只记录innodb日志，myisam表也一样有二进制日志。</p><p>对于事务表的操作，二进制日志<strong>只在事务提交的时候一次性写入基于事务的innodb二进制日志)，提交前的每个二进制日志记录都先cache，提交时写入</strong>。</p><p>所以，对于事务表来说，一个事务中可能包含多条二进制日志事件，它们会在提交时一次性写入。而对于非事务表的操作，每次执行完语句就直接写入。</p><h4 id="Bin-Log-和-Redo-log"><a href="#Bin-Log-和-Redo-log" class="headerlink" title="Bin Log 和 Redo log"></a><a href="https://www.jianshu.com/p/4bcfffb27ed5" target="_blank" rel="noopener">Bin Log 和 Redo log</a></h4><p><strong>首先，我们先来看看一次查询/更新语句流程图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5148507-ca8930bca4e10d05.png" alt="img"></p><p><strong>本文会将重点放在执行器&lt;-&gt;存储引擎之间的交互。</strong></p><blockquote><p>mysql不是每次数据更改都立刻写到磁盘，而是会先将修改后的结果暂存在内存中,当一段时间后，再一次性将多个修改写到磁盘上，减少磁盘io成本，同时提高操作速度。</p></blockquote><ul><li><p>mysql通过WAL(write-ahead logging)技术保证事务</p><p>在同一个事务中，每当数据库进行修改数据操作时，将修改结果更新到内存后，会在redo log添加一行记录记录“需要在哪个数据页上做什么修改”，并将该记录状态置为prepare，等到commit提交事务后，会将此次事务中在redo log添加的记录的状态都置为commit状态，之后将修改落盘时，会将redo log中状态为commit的记录的修改都写入磁盘。过程如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/5148507-ce39f679f490b64f.png" alt="img"></p></li><li><p>redo log记录方式</p><p>redolog的大小是固定的，在mysql中可以通过修改配置参数innodb_log_files_in_group和innodb_log_file_size配置日志文件数量和每个日志文件大小，redolog采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。如下图</p><p><img src="https://upload-images.jianshu.io/upload_images/5148507-bef2727de72b311f.png" alt="img"></p></li></ul><p>  write pos表示日志当前记录的位置，当ib_logfile_4写满后，会从ib_logfile_1从头开始记录；check point表示将日志记录的修改写进磁盘，完成数据落盘，数据落盘后checkpoint会将日志上的相关记录擦除掉，即write pos-&gt;checkpoint之间的部分是redo log空着的部分，用于记录新的记录，checkpoint-&gt;write pos之间是redo log待落盘的数据修改记录。当writepos追上checkpoint时，得先停下记录，先推动checkpoint向前移动，空出位置记录新的日志。</p><p>  有了redo log，当数据库发生宕机重启后，可通过redo log将未落盘的数据恢复，即保证已经提交的事务记录不会丢失。</p><p>  有了redo log，为啥还需要binlog呢？</p><blockquote><p>1、redo log的大小是固定的，日志上的记录修改落盘后，日志会被覆盖掉，无法用于数据回滚/数据恢复等操作。<br> 2、redo log是innodb引擎层实现的，并不是所有引擎都有。</p></blockquote><ul><li><strong>基于以上，binlog必不可少</strong></li></ul><blockquote><p>1、binlog是server层实现的，意味着所有引擎都可以使用binlog日志<br> 2、binlog通过追加的方式写入的，可通过配置参数max_binlog_size设置每个binlog文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。<br> 3、binlog有两种记录模式，statement格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</p></blockquote><p>binlog和redo log必须保持一致，不允许出现binlog有记录但redolog没有的情况，反之亦然。之前说过在一个事务中，redolog有prepare和commit两种状态，所以，在redolog状态为prepare时记录binlog可保证两日志的记录一致，下图列出各种情况来说明。</p><p><img src="https://upload-images.jianshu.io/upload_images/5148507-a47b099cea71c913.png" alt="img"></p><p><strong>现在我们再来看看整个完整的流程图</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/5148507-1a29473c24f0c5b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><p><strong>相关参数设置建议：</strong></p><blockquote><p>1、innodb_flush_log_at_trx_commit：设置为1，表示每次事务的redolog都直接持久化到磁盘（注意是这里指的是redolog日志本身落盘），保证mysql重启后数据不丢失。<br> 2、sync_binlog： 设置为1，表示每次事务的binlog都直接持久化到磁盘（注意是这里指的是binlog日志本身落盘），保证mysql重启后binlog记录是完整的。</p></blockquote><p>#Java集合</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容为1.5倍(Vector为2倍)</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">      newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="散列值原理"><a href="#散列值原理" class="headerlink" title="散列值原理"></a>散列值原理</h4><p>主要做了两件事：</p><ol><li><p>扰动函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将散列值的前16位和其本身做一个异或：为了防止散列值分布不均匀；</p></li><li><p>低位掩码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是只保留低位作为下标。这也是Hashmap大小取$2^n$的原因。</p></li></ol><h4 id="多线程不安全"><a href="#多线程不安全" class="headerlink" title="多线程不安全"></a>多线程不安全</h4><ol><li>1.7中拉链法插入节点采用头插法，可能形成环从而导致死锁；</li><li>1.8改为了尾插法，不会造成死锁，但有数据丢失的危险。</li></ol><h4 id="和HashTable的区别"><a href="#和HashTable的区别" class="headerlink" title="和HashTable的区别"></a>和HashTable的区别</h4><ol><li><p>HashMap 是线程不安全的，HashTable 是线程安全的；</p></li><li><p>由于线程安全，所以 HashTable 的效率比不上 HashMap（全局synchronized）；</p></li><li><p>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；</p></li><li><p>HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</p></li><li><p>HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode。</p></li></ol><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>####并发度</p><p>程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。</p><p>当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）</p><h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><blockquote><p><a href="https://blog.csdn.net/qq_44377709/article/details/106643703" target="_blank" rel="noopener">关于Java的i=i++和i=++i</a></p></blockquote><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型 JMM"></a>Java内存模型 JMM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>当前线程执行字节码的行号指示器</li><li>若正执行本地方法，则计数器值为空</li><li>唯一不会发生OOM的区域</li></ul><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul><li>描述的是Java方法执行的内存线程模型</li><li>方法执行的时候，JVM会创建一个栈帧，其中包括局部变量表、操作数栈、动态连接、方法出口等</li><li>每一个方法被调用直至执行完毕的全过程，对应着一个栈帧在虚拟机栈中入栈到出栈的全过程</li><li>OOM：栈深度大于JVM允许的深度、无法申请到足够的内存空间</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul><li>OOM：没有内存完成实例分配且堆无法扩展时</li></ul><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><h4 id="什么情况下会OOM"><a href="#什么情况下会OOM" class="headerlink" title="什么情况下会OOM"></a>什么情况下会OOM</h4><h4 id="如何排查"><a href="#如何排查" class="headerlink" title="如何排查"></a>如何排查</h4><h3 id="创建对象的全过程"><a href="#创建对象的全过程" class="headerlink" title="创建对象的全过程"></a>创建对象的全过程</h3><ol><li><p>检查该指令对应的类能否在常量池中定位到一个类的符号引用，并检查该类是否已被加载、解析、初始化</p></li><li><p>为该对象分配内存空间</p><p><em>如何保证更新内存指针的原子性？</em></p><ul><li>CAS+失败重试</li><li>本地线程分配缓冲（TLAB），即每个线程在堆中预先分配一块独占内存</li></ul></li><li><p>内存空间初始化为零值，设置对象头</p></li><li><p>执行构造函数</p></li></ol><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><table><thead><tr><th align="center">Mark Word (64Bits)</th><th>锁状态</th></tr></thead><tbody><tr><td align="center">unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:0 | lock:01</td><td>无锁</td></tr><tr><td align="center">thread:54 |    epoch:2 (时间戳)        | unused:1 | age:4 | biased_lock:1 | lock:01</td><td>偏向锁</td></tr><tr><td align="center">ptr_to_lock_record:62                                              |lock:00</td><td>轻量级锁</td></tr><tr><td align="center">ptr_to_heavyweight_monitor:62                                     |lock:10</td><td>重量级锁</td></tr><tr><td align="center">|lock:11</td><td>GC标记</td></tr></tbody></table><h2 id="TODO-类加载机制"><a href="#TODO-类加载机制" class="headerlink" title="(TODO) 类加载机制"></a>(TODO) 类加载机制</h2><h3 id="类加载的全过程"><a href="#类加载的全过程" class="headerlink" title="类加载的全过程"></a>类加载的全过程</h3><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="如何破坏双亲委派模型和其意义？-MySQL的Driver"><a href="#如何破坏双亲委派模型和其意义？-MySQL的Driver" class="headerlink" title="如何破坏双亲委派模型和其意义？(MySQL的Driver)"></a>如何破坏双亲委派模型和其意义？(MySQL的Driver)</h4><p><strong>因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。</strong></p><p>JDBC的Driver接口定义在JDK中，其实现由各个数据库的服务商来提供，比如MySQL驱动包。DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但是DriverManager位于 $JAVA_HOME中jre/lib/rt.jar 包，由BootStrap类加载器加载，而其Driver接口的实现类是位于服务商提供的 Jar 包，<strong>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。</strong><code>connection= DriverManager.getConnection(url,username,password);</code>也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。我们知道，BootStrap类加载器默认只负责加载 $JAVA_HOME中jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。</p><h4 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h4><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal的几种误区"><a href="#ThreadLocal的几种误区" class="headerlink" title="ThreadLocal的几种误区"></a>ThreadLocal的几种误区</h3><blockquote><p> 最近由于需要用到ThreadLocal，在网上搜索了一些相关资料，发现对ThreadLocal经常会有下面几种<strong>误解</strong></p><p> 一、ThreadLocal是java线程的一个实现<br>   ThreadLocal的确是和java线程有关，不过它并不是java线程的一个实现，它只是用来维护本地变量。针对每个线程，提供自己的变量版本，主要是为了避免线程冲突，每个线程维护自己的版本。彼此独立，修改不会影响到对方。</p><p> 二、ThreadLocal是相对于每个session的</p><p>​    ThreadLocal顾名思义，是针对线程。在java web编程上，每个用户从开始到会话结束，都有自己的一个session标识。但是ThreadLocal并不是在会话层上。其实，Threadlocal是独立于用户session的。它是一种服务器端行为，当服务器每生成一个新的线程时，就会维护自己的ThreadLocal。对于这个误解，个人认为应该是开发人员在本地基于一些应用服务器测试的结果。众所周知，一般的应用服务器都会维护一套线程池，也就是说，对于每次访问，并不一定就新生成一个线程。而是自己有一个线程缓存池。对于访问，先从缓存池里面找到已有的线程，如果已经用光，才去新生成新的线程。所以，由于开发人员自己在测试时，一般只有他自己在测，这样服务器的负担很小，这样导致每次访问可能是共用同样一个线程，导致会有这样的误解：每个session有一个ThreadLocal</p><p> 三、ThreadLocal是相对于每个线程的，用户每次访问会有新的ThreadLocal</p><p> 理论上来说，ThreadLocal是的确是相对于每个线程，每个线程会有自己的ThreadLocal。但是上面已经讲到，一般的应用服务器都会维护一套线程池。因此，不同用户访问，可能会接受到同样的线程。因此，在做基于TheadLocal时，需要谨慎，避免出现ThreadLocal变量的缓存，导致其他线程访问到本线程变量</p><p> 四、对每个用户访问，ThreadLocal可以多用<br>    可以说，ThreadLocal是一把双刃剑，用得来的话可以起到非常好的效果。但是，ThreadLocal如果用得不好，就会跟全局变量一样。代码不能重用，不能独立测试。因为，一些本来可以重用的类，现在依赖于ThreadLocal变量。如果在其他没有ThreadLocal场合，这些类就变得不可用了。个人觉得ThreadLocal用得很好的几个应用场合，值得参考</p><p> 1、存放当前session用户：quake want的jert</p><p> 2、存放一些context变量，比如webwork的ActionContext</p><p> 3、存放session，比如Spring hibernate orm的session</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>管理数据库连接池</strong>  TheadLocal能够实现当前线程的操作都是用同一个Connection，保证了事务。</p><p><strong>既然ThreadLocal当当前线程中没有时去新建一个新的，有的话就用当前线程中的，那数据库连接池已经有了这种功能啊，还要ThreadLocal干什么？</strong></p><p>由于请求中的一个事务涉及多个 DAO 操作，而这些 DAO 中的 Connection 不能从连接池中获得，如果是从连接池获得的话，两个 DAO 就用到了两个Connection，这样的话是没有办法完成一个事务的。DAO 中的 Connection 如果是从 ThreadLocal 中获得 Connection 的话那么这些 DAO 就会被纳入到同一个 Connection 之下。当然了，这样的话，DAO 中就不能把 Connection 给关了，关掉的话，下一个使用者就不能用了。 <strong><code>将对象和线程绑定</code></strong></p><p>不同HTTP请求复用Tomcat线程——&gt;定义DBUtil类，类中有static的ThreadLocal对象——&gt;从数据库连接池里获得Connection，和线程绑定。</p><h2 id="关于线程挂起的几个方法"><a href="#关于线程挂起的几个方法" class="headerlink" title="关于线程挂起的几个方法"></a>关于线程挂起的几个方法</h2><h3 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h3><p>首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。</p><p>（1）Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</p><p>（2）Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</p><p>（3）Thread.sleep()到时间了会自动唤醒，然后继续执行；</p><p>（4）Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</p><p>（5）Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</p><p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p><h3 id="Thread-sleep-和Condition-await-的区别"><a href="#Thread-sleep-和Condition-await-的区别" class="headerlink" title="Thread.sleep()和Condition.await()的区别"></a>Thread.sleep()和Condition.await()的区别</h3><p>我们再来看看Thread.sleep()和Condition.await()的区别。</p><p>其实，这个题目和上面的题目比较类似，因为本来Object.wait()和Condition.await()的原理就比较类似，可以参考之前彤哥写的《死磕 java线程系列之线程的生命周期》之篇文章。</p><p>这个题目的回答思路跟Object.wait()是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p><p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程，可以参考之前彤哥写的《死磕 java同步系列之ReentrantLock源码解析（二）——条件锁》这篇文章。</p><p>看到这里，今天开篇提的那个问题是不是就有答案了呢【本文由公从号“彤哥读源码”原创】？</p><h3 id="Thread-sleep-和LockSupport-park-的区别"><a href="#Thread-sleep-和LockSupport-park-的区别" class="headerlink" title="Thread.sleep()和LockSupport.park()的区别"></a>Thread.sleep()和LockSupport.park()的区别</h3><p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p><p>（1）从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且<strong>都不会释放当前线程占有的锁资源</strong>；</p><p>（2）Thread.sleep()没法从外部唤醒，只能自己醒过来；</p><p>（3）LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</p><p>（4）Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</p><p>（5）LockSupport.park()方法不需要捕获中断异常；</p><p>（6）Thread.sleep()本身就是一个native方法；</p><p>（7）LockSupport.park()底层是调用的Unsafe的native方法；</p><h3 id="Object-wait-和LockSupport-park-的区别"><a href="#Object-wait-和LockSupport-park-的区别" class="headerlink" title="Object.wait()和LockSupport.park()的区别"></a>Object.wait()和LockSupport.park()的区别</h3><p>二者都会阻塞当前线程的运行，他们有什么区别呢？经过上面的分析相信你一定很清楚了，真的吗？往下看！</p><p>（1）Object.wait()方法需要在synchronized块中执行；</p><p>（2）LockSupport.park()可以在任意地方执行；</p><p>（3）Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</p><p>（4）LockSupport.park()不需要捕获中断异常【本文由公从号“彤哥读源码”原创】；</p><p>（5）Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</p><p>（6）LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</p><p>（7）<strong>如果在wait()之前执行了notify()会怎样？抛出IllegalMonitorStateException异常</strong>；</p><p>（8）<strong>如果在park()之前执行了unpark()会怎样？线程不会被阻塞，直接跳过park()，继续执行后续内容；</strong></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="Volatile的语义"><a href="#Volatile的语义" class="headerlink" title="Volatile的语义"></a><span id="volatile">Volatile的语义</span></h3><ol><li><p><strong>禁止指令重排序</strong></p><p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而无法保证复制操作顺序和代码中顺序一致。<strong><code>Within-Thread As-If-Serial Semantic</code></strong></p><p>编译后，有volatile的变量在赋值后多执行了一个<strong><code>lock add1 $F0x0, (%esp)</code></strong>操作 </p><p><strong><code>lock前缀</code></strong>(Store Barrier)</p><ol><li><p>使得本CPU的cache写入内存，相当于store+write，从而使得对其他线程可见; </p></li><li><p>写入内存要求指令重排序不影响结果的正确性，意味着所有之前的操作都已经执行完成</p></li></ol></li><li><p>将变量的更新直接写回主存，并使其他线程工作内存中的值失效。（此处的主存为JVM内部的概念）</p></li><li><p>Happens-before原则：由JMM(Java Memory Model)自动实现的天然有序性保证</p><p><strong>A和B满足Happens-before规则并不代表A一定在B于时间上先行发生。只要A-&gt;B和B-&gt;A的执行结果相同，JMM就认可该种重排序。</strong></p><blockquote><p><strong>程序顺序规则</strong>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</p><p><strong>监视器锁规则</strong>：对一个线程的解锁，happens-before于随后对这个线程的加锁</p><p><strong>volatile变量规则</strong>： 对一个volatile域的写，happens-before于后续对这个volatile域的读(<strong>时间上的先后!!!</strong>)</p><p><strong>传递性</strong>：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</p><p><strong>start()规则</strong>： 如果线程A执行操作<code>ThreadB_start()</code>(启动线程B) ,  那么A线程的<code>ThreadB_start()</code>happens-before 于B中的任意操作</p><p><strong>join()原则</strong>： 如果A执行<code>ThreadB.join()</code>并且成功返回，那么线程B中的任意操作happens-before于线程A从<code>ThreadB.join()</code>操作成功返回。</p><p><strong>interrupt()原则</strong>： 对线程<code>interrupt()</code>方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测是否有中断发生</p><p><strong>finalize()原则</strong>：一个对象的初始化完成先行发生于它的<code>finalize()</code>方法的开始</p></blockquote></li></ol><h3 id="为什么不用Volatile修饰每一个变量？"><a href="#为什么不用Volatile修饰每一个变量？" class="headerlink" title="为什么不用Volatile修饰每一个变量？"></a>为什么不用Volatile修饰每一个变量？</h3><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><blockquote><p>Synchronized是通过对象内部的一个叫做 <strong>监视器锁（Monitor）来实现的</strong>。<strong>但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间</strong>，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 <strong>“重量级锁”</strong>。</p></blockquote><p><a href="https://juejin.im/post/6844903640197513230" target="_blank" rel="noopener">Synchronized全分析</a></p><p>从语法上讲，<strong>Synchronized可以把任何一个非null对象作为”锁”</strong>，在HotSpot JVM实现中，锁有个专门的名字：<strong>对象监视器（Object Monitor）</strong>。</p><p><strong>Synchronized总共有三种用法</strong>：</p><blockquote><ol><li>当synchronized作用在实例方法时，<strong>监视器锁（monitor）便是对象实例（this）</strong>；</li><li>当synchronized作用在静态方法时，<strong>监视器锁（monitor）便是对象的Class实例</strong>，因为Class数据存在于永久代，<strong>因此静态方法锁相当于该类的一个全局锁</strong>；</li><li>当synchronized作用在某一个对象实例时，<strong>监视器锁（monitor）便是括号括起来的对象实例</strong>；</li></ol></blockquote><hr><p>代码块的同步通过在字节码前后添加<strong><code>monitorenter</code></strong>和<strong><code>monitorexit</code></strong>指令实现：</p><p><strong><code>monitorenter</code></strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><ol><li><strong>如果monitor的进入数为0</strong>，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li><li><strong>如果线程已经占有该monitor</strong>，只是重新进入，则进入monitor的进入数加1；</li><li><strong>如果其他线程已经占用了monitor</strong>，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li></ol><p><strong><code>monitorexit</code></strong>：执行monitorexit的线程必须是objectref所对应的monitor的所有者。<strong>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者</strong>。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>方法的同步并没有通过指令 <strong><code>monitorenter</code></strong> 和 <strong><code>monitorexit</code></strong> 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 <strong><code>ACC_SYNCHRONIZED</code></strong> 标示符。<strong>JVM就是根据该标示符来实现方法的同步的</strong>：</p><blockquote><p>当方法调用时，<strong>调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置</strong>，如果设置了，<strong>执行线程将先获取monitor</strong>，获取成功之后才能执行方法体，<strong>方法执行完后再释放monitor</strong>。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p></blockquote><p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。<strong>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度</strong>，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>重要变量：<strong>state</strong>，需用CAS操作修改。不同锁的state表示不同含义，总的来说通过查询state判定线程能否获得锁。</p><h4 id="获取独占锁的全过程"><a href="#获取独占锁的全过程" class="headerlink" title="获取独占锁的全过程"></a>获取独占锁的全过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE),arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>进入锁自定义的<strong><code>tryAcquire()</code></strong>方法，若获取成功则结束，否则</li><li>使用<code>addWaiter()</code>方法将该线程包装为node并添加至队尾，然后</li><li>使用<code>acquireQueued</code>方法无限循环判断该node的predecessor是否是头节点，若是则<code>tryAcquire</code>；若非则通过<code>shouldParkAfterFailedAcquire()</code>将其前驱节点的<code>waitStatus</code>设置为SIGNAL，通过<code>parkAndCheckInterrupt()</code>将该线程挂起。</li></ol><p><strong>此处无限循环并不是指不间断的循环，因为在<code>parkAndCheckInterrupt()</code>中有<code>LockSupport.park()</code>方法将线程挂起，直到上一个线程释放锁时通过<code>unpark</code>唤醒下一个线程时才继续开始循环。</strong></p><p><img src="https://img2018.cnblogs.com/blog/1095436/201903/1095436-20190322230440870-1279050816.png" alt="img"></p><h4 id="释放独占锁的过程"><a href="#释放独占锁的过程" class="headerlink" title="释放独占锁的过程"></a>释放独占锁的过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果满足释放锁的条件，则唤醒后面的节点。</p><p>根据<code>unparkSuccessor()</code>，如果后继节点为null或waitStatus == CANCELED，则从队尾向前找到第一个满足要求的节点。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>什么时候更新头节点？</p><p>在<code>acquireQueued()</code>时，若当前节点执行到<code>if(p == head &amp;&amp; tryAcquire(arg))</code>时获取到了锁，则将当前node设为头节点，并将前驱节点的next设为null以帮助GC</p></li></ol><h3 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量 Condition"></a>条件变量 Condition</h3><blockquote><p>调用条件变量的<code>signal</code>和<code>await</code>方法前必须先获得条件变量对应的锁。</p></blockquote><p>和同步队列不同的是，条件队列是单向队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>await()</code>方法做了以下三件事：1. 通过<code>addConditionWaiter()</code>将线程包装为node并添加至条件队列；2. 通过<code>fullyRelease()</code>释放锁并唤醒后继节点；3.  <code>while (!isOnSyncQueue(node))</code>循环判断节点是否已被移出条件队列，若是则退出循环并用<code>acquiceQueued</code>方法尝试获得锁。</p><p>对应的<code>signal()</code>方法将节点移动至同步队列。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><strong>state</strong>表示锁的重入次数</p><p>公平锁/非公平锁的关键在于<code>tryAcquire()</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (getState()==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 公平锁标志</span></span><br><span class="line">    <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">        compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>hasQueuedPredecessors()</code>方法，若AQS有前驱节点返回true；若AQS队列为空或当前线程节点为AQS的第一个节点则返回false。</p><p>特点：</p><p><code>tryLock()</code>方法：若没有线程持有锁，则该线程获得锁；否则返回false。不会引起线程阻塞。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p><strong>state</strong>的高16位表示读状态，低16位表示写状态。</p><p>一个ReadLock(共享锁)和一个WriteLock(独占锁)，分别依赖Sync实现。</p><p>下图为共享锁和独占锁doacquire方法的区别</p><p>![image-20200808114224004](/Users/silverlining/Library/Application Support/typora-user-images/image-20200808114224004.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate也就是state的更新值大于0，代表可以继续acquire</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 判断后继节点是否存在，如果存在是否是共享模式的节点</span></span><br><span class="line">        <span class="comment">// 然后进行共享模式的释放</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>分为写锁/悲观读锁/乐观读锁。其中所有锁均为不可重入锁。</p><h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>头尾为item为null的哨兵节点。</p><p>尾部入队，头部出队。均使用unsafe的CAS操作。</p><p>计算<code>size()</code>为遍历整个队列，在并发的环境下不准确。</p><blockquote><p><strong><em><a href="https://stackoverflow.com/questions/2758966/size-of-concurrentlinkedqueue" target="_blank" rel="noopener">Why not volatile or atomic?</a></em></strong></p><p>Imagine you have two threads, one adding a new item, and the other deleting an item. There are no items in the queue at the start.</p><p>Suppose the first thread adds the item, immediately followed by the other thread removing the item and decrementing the size, at which point your size is at -1, then the first thread increments the size to 0.</p><p>A slightly contrived example, but you would need to make the whole operation atomic in order to ensure that no other threads could get access to the size of -1.</p></blockquote><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>采用单向链表。入队和出队分别用一个ReentrantLock。另外有notEmpty, notFull两个condition，当队列为空出队或队列满入队是会被放入对应条件队列等待，相当于一个生产者-消费者模型。</p><p><code>offer()</code>和<code>put()</code>: <code>offer()</code>是不阻塞的，若队列已满则丢弃。</p><p><code>poll()</code>和<code>take()</code>: <code>poll()</code>是不阻塞的，队列为空返回null。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>通过全局独占锁实现同步，类似于在方法上添加<code>synchronized</code>，开销较大。</p><blockquote><p><code>size()</code>方法准确度: <code>ArrayBlockingQueue</code> &gt; <code>LinkedBlockingQueue</code> &gt; <code>ConcurrentLinkedQueue</code></p><p>ABQ<code>size()</code>加全局锁；LBQ入队、出队时改变<code>count</code>加锁；CLQ无锁。</p></blockquote><p>##(TODO) Volatile, Synchronized和Lock的选择</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">线程池</a></p><p><a href="https://www.cnblogs.com/paulwang92115/p/12168023.html" target="_blank" rel="noopener">AQS</a></p><p><a href="https://www.zybuluo.com/kiraSally/note/897227" target="_blank" rel="noopener">AQS2</a></p><p><a href="https://blog.csdn.net/anlian523/article/details/106344926/" target="_blank" rel="noopener">AQS3</a></p><p><a href="https://blog.csdn.net/qq_37685457/article/details/89738269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">多线程通信的七种方式</a></p></blockquote><p>线程池主要解决两个问题：</p><ol><li>创建和销毁线程需要开销。线程池里的线程是可复用的，在大量执行异步任务时能够提供较为良好的性能；</li><li>线程池提供了一种资源限制和管理的手段，eg：限制线程的个数、动态新增线程等。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul><li><p><code>ctl</code>: <code>AtomicInteger</code>变量，用一个变量同时记录线程池状态和线程池中线程个数，类似ReentrantReadWriteLock.</p></li><li><p><code>corePoolSize</code>: 线程池核心线程数</p></li><li><p><code>maximumPoolSize</code>: 线程池最大线程数量</p></li><li><p><code>ThreadFactory</code>: 创建线程的工厂</p></li><li><p><code>keepAliveTime</code>: 闲置非核心线程的存活时间</p></li><li><p><code>RejectExecutionHandler</code>: 拒绝策略。包括CallerRunsPolicy/AbortPolicy/DiscardPolicy/DiscardOldestPolicy</p></li><li><p><code>workQueue</code>: 保存等待执行任务的阻塞队列</p></li></ul><p>###线程池类型</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h4><p>顾名思义，线程池内线程数量固定(核心线程数和最大线程数都为<code>nThreads</code>。阻塞队列为长度<code>Integer.MAXVALUE</code>的<code>LinkedBlockingQueue</code>。</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h4><p>只处理一个线程的线程池，不是pool，是executor了。阻塞队列同样为长度<code>Integer.MAXVALUE</code>的<code>LinkedBlockingQueue</code>。</p><h5 id="这线程池有什么用？"><a href="#这线程池有什么用？" class="headerlink" title="这线程池有什么用？"></a>这线程池有什么用？</h5><p>保证线程按顺序执行？</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h4><p>按需创建的线程池。核心线程数为0，最大线程数为<code>Integer.MAX_VALUE</code>。阻塞队列为<code>SynchronousQueue</code>，最多只有一个元素。</p><h3 id="提交新线程-execute"><a href="#提交新线程-execute" class="headerlink" title="提交新线程 execute()"></a>提交新线程 <code>execute()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，抛出NPE</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ctl变量获得线程池状态和线程池中线程个数; ctl是AtomicInteger变量，使用get()方法</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 若当前线程池中线程个数小于核心线程数，则开启新线程(Worker)</span></span><br><span class="line">    <span class="keyword">if</span> (workCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, core = <span class="keyword">true</span>)) <span class="comment">// 若成功添加则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// addWorker中可能由于线程池状态非Running或大于核心线程数返回false，则重新读取ctl</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若线程池为Running状态，则只可能是线程数大于核心线程数，添加至阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 二次检查，为接下来做准备</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果不是Running状态了则把人物从阻塞队列中移除并执行拒绝策略</span></span><br><span class="line">        <span class="comment">// 为什么要反复横跳？？？</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 防止此时所有线程都执行完了且设置了corePoolSize过期时间/coreSize设置为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一种情况，阻塞队列满，向非核心线程池添加</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul><li><code>RUNNING</code>    -1</li><li><code>SHUTDOWN</code>    拒绝新任务但是处理阻塞队列中的任务    0</li><li><code>STOP</code>    拒绝新任务并且抛弃阻塞队列中的人物，同时中断现在正执行的任务    1</li><li><code>TIDYING</code>    所有任务都执行完后当前线程池活动线程数为0，即将调用<code>terminated()</code>方法    2</li><li><code>TERMINATED</code>    3</li></ul><h3 id="线程复用"><a href="#线程复用" class="headerlink" title="线程复用"></a><a href="https://blog.csdn.net/weixin_38106322/article/details/105429550" target="_blank" rel="noopener">线程复用</a></h3><p>简单的从源码来总结下，执行任务先调用的是t.start()方法，这个t是个Thread对象，而这个Thread对象则是从Worker对象里获得的，在Worker在做初始化时就会赋值Thread，同时Worker初始化Thread对象时又是以自己作为参数来完成，而Worker对象又是个实现了Runnable接口的类，那Worker对象就肯定有自己的run方法，所以t.start()方法真正意义上调用的是Worker对象中重写的run方法，而这个Worker对象中的run方法里没有所谓的本地start方法，JVM自然不会再创建新的线程，而是把它当普通方法一样执行。再加上whlie循环体，这样就做到了Worker对象新建的线程始终都会在一个大循环里，而这个线程会反复的获取任务，接着执行任务，直到任务都执行完毕，这就是线程池实现“线程复用”的原理。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="IO密集型和CPU密集型，线程池参数分别怎么设置？"><a href="#IO密集型和CPU密集型，线程池参数分别怎么设置？" class="headerlink" title="IO密集型和CPU密集型，线程池参数分别怎么设置？"></a>IO密集型和CPU密集型，线程池参数分别怎么设置？</h4><h2 id="线程同步器"><a href="#线程同步器" class="headerlink" title="线程同步器"></a>线程同步器</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="CountDownLatch和-join-的区别"><a href="#CountDownLatch和-join-的区别" class="headerlink" title="CountDownLatch和.join()的区别"></a><code>CountDownLatch</code>和<code>.join()</code>的区别</h4><ol><li><code>.join()</code>使线程阻塞到子线程结束；<code>CountDownLatch</code>允许在自线程运行中递减基数/多次递减；</li><li>若使用线程池直接添加<code>Runnable</code>至线程池，则无法直接调用线程的<code>.join()</code>方法，此时只能用<code>CountDownLatch</code>.</li></ol><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><h2 id="题目：n个线程交替打印"><a href="#题目：n个线程交替打印" class="headerlink" title="题目：n个线程交替打印"></a><a href="https://blog.csdn.net/xiaokang123456kao/article/details/77331878" target="_blank" rel="noopener">题目：n个线程交替打印</a></h2><p><strong>三种方法</strong></p><ol><li>使用Lock</li><li>使用Lock + Condition</li><li>使用Semaphore</li></ol><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>Redis的key和string大小限制均为512MB。</p></blockquote><h2 id="常见问题-1"><a href="#常见问题-1" class="headerlink" title="常见问题"></a>常见问题</h2><p>###Redis是单线程还是多线程？</p><p>通常说Redis单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><h3 id="为什么Redis单线程却需要处理事物并发问题？"><a href="#为什么Redis单线程却需要处理事物并发问题？" class="headerlink" title="为什么Redis单线程却需要处理事物并发问题？"></a><span id="redis">为什么Redis单线程却需要处理事物并发问题？</span></h3><p>因为当<strong>多个client端同时发送命令时</strong>，Redis处理命令的顺序是不确定的。</p><p>如A事务中有c,d,e三个命令，B事务中有h,l两个命令；当两个客户端同时发送给redis时，redis可能先执行c，然后又执行l，顺序变为c-&gt;h-&gt;d-&gt;l-&gt;e，而期望的顺序是c-&gt;d-&gt;e-&gt;h-&gt;l。因此只有Redis在事务执行期间不再响应其他客户端请求，才能保证一个客户端上的事务完整按序执行。</p><blockquote><p>Redis处理多个Client同时发送命令用到的是IO多路复用技术。“多路”指的是多个网络连接，“复用”指的是复用同一个线程。详见<a href="https://draveness.me/redis-io-multiplexing/" target="_blank" rel="noopener">Redis和I/O多路复用</a></p></blockquote><h3 id="Redis如何处理过期数据？"><a href="#Redis如何处理过期数据？" class="headerlink" title="Redis如何处理过期数据？"></a>Redis如何处理过期数据？</h3><p><strong>Redis对于过期键有三种清除策略</strong>：</p><ul><li><p>被动删除（惰性删除）：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</p></li><li><p>主动删除（定期删除）：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</p><p>Redis会周期性的随机测试一批设置了过期时间的key并进行处理。测试到的已过期的key将被删除。典型的方式为,Redis每秒做10次如下的步骤：</p><ol><li>随机测试100个设置了过期时间的key</li><li>删除所有发现的已过期的key</li><li>若删除的key超过25个则重复步骤1</li></ol><p>这是一个基于概率的简单算法，基本的假设是抽出的样本能够代表整个key空间，redis持续清理过期的数据直至将要过期的key的百分比降到了25%以下。这也意味着在任何给定的时刻已经过期但仍占据着内存空间的key的量最多为每秒的写操作量除以4</p></li><li><p>当前已用内存超过maxmemory限定时，触发主动清理策略</p></li></ul><h3 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h3><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0版本后增加以下两种：</p><ol><li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><p><strong>Redis的LRU和LFU与常规算法并不相同，是通过在key中维护一个时间戳来实现的。<a href="https://www.jianshu.com/p/c8aeb3eee6bc" target="_blank" rel="noopener">详见这里</a></strong></p><h3 id="Redis和Memcache的比较"><a href="#Redis和Memcache的比较" class="headerlink" title="Redis和Memcache的比较"></a>Redis和Memcache的比较</h3><p>// TODO</p><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>RDB(snapshotting)做镜像全量持久化，<a href="https://redisbook.readthedocs.io/en/latest/internal/aof.html" target="_blank" rel="noopener">AOF(append-only file)</a>做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p><blockquote><p><strong>这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</strong></p></blockquote><h4 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h4><blockquote><p><a href="https://draveness.me/whys-the-design-redis-bgsave-fork/" target="_blank" rel="noopener">为什么 Redis 快照使用子进程</a></p></blockquote><p><strong>fork()</strong> 当bgsave执行时，Redis主进程会判断当前是否有fork()出来的子进程，若有则忽略，若没有则会<strong>fork()出一个子进程来执行rdb文件持久化的工作</strong>，子进程与Redis主进程共享同一份内存空间，所以子进程可以搞他的rdb文件持久化工作，主进程又能继续他的对外提供服务，二者互不影响。</p><p><strong>Copyonwrite</strong> 主进程fork()子进程之后，内核把主进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向主进程。这也就是共享了主进程的内存，当其中某个进程写内存时(这里肯定是主进程写，因为子进程只负责rdb文件持久化工作，不参与客户端的请求)，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入内核的一个中断例程。中断例程中，内核就会把触发的异常的页复制一份（这里仅仅复制异常页，也就是所修改的那个数据页，而不是内存中的全部数据），于是主子进程各自持有独立的一份。</p><p><strong>操作系统提供的<code>fork()</code>函数也是Redis采用子进程而非多线程的原因：开发者无需手动实现繁琐的copyonwrite操作。</strong></p><h4 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h4><p><strong>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</strong></p><p>AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。Redis 还可以同时使用AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><ul><li>Rewrite 重写</li></ul><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root@hadoop102 myredis</span>]<span class="meta"># redis-server redis.conf</span></span><br><span class="line">[<span class="meta">root@hadoop102 myredis</span>]<span class="meta"># redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不能经常去做，需要达到一定的量级</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; bgrewriteaof</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 1000</span><br><span class="line">incrby k1 100</span><br><span class="line">incrby k1 100</span><br><span class="line">incrby k1 100</span><br><span class="line">incrby k1 100</span><br><span class="line"></span><br><span class="line">        ↓</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> k1 1400</span><br></pre></td></tr></table></figure><ul><li>Redis如何实现重写？</li></ul><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</p><ul><li>何时重写</li></ul><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。</p><p><img src="https://upload-images.jianshu.io/upload_images/9193428-fd2865c61db3c6bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,如果Redis的AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对AOF进行重写。</p><h4 id="两种持久化方式的优缺点"><a href="#两种持久化方式的优缺点" class="headerlink" title="两种持久化方式的优缺点"></a>两种持久化方式的优缺点</h4><ul><li><strong>RDB</strong></li></ul><p><strong>RDB 的优点:</strong></p><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p><strong>RDB 的缺点:</strong></p><p>如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p><ul><li><strong>AOF</strong></li></ul><p><strong>AOF 的优点:</strong></p><p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到FLUSHALL 执行之前的状态。</p><p><strong>AOF 的缺点:</strong></p><p>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。</p><h3 id="五种数据结构的实现"><a href="#五种数据结构的实现" class="headerlink" title="五种数据结构的实现"></a>五种数据结构的实现</h3><p>ZSet基于<a href="https://juejin.im/post/6844903446475177998#comment" target="_blank" rel="noopener">跳表(SkipList)</a>结构。</p><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="主从复制-1"><a href="#主从复制-1" class="headerlink" title="主从复制"></a>主从复制</h3><p> 主从复制的配置还是比较简单的，下面来了解下主从复制的实现原理</p><p>Redis的主从复制过程大体上分3个阶段：<strong>建立连接</strong>、<strong>数据同步</strong>、<strong>命令传播</strong></p><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>这个阶段主要是从服务器发出<code>slaveof</code>命令之后，与主服务器如何建立连接，为数据同步做准备的过程。</p><p>1）在<code>slaveof</code>命令执行之后，从服务器根据设置的master的ip地址和端口，创建连向主服务器的socket套接字连接，连接成功后，从服务器会为这个套接字关联一个专门的处理器，用于处理后续的复制工作</p><p>2）建立连接之后，从服务器会向主服务器发送<code>ping</code>命令，确认主服务器是否可用，以及当前是否可用接受处理命令。如果收到主服务器的<code>pong</code>回复说明是可用的，否则有可能是网络超时或主服务器阻塞，从服务器会断开连接发起重连</p><p>3）身份验证。如果主服务器设置了<code>requirepass</code>选项，那么从服务器必须配置<code>masterauth</code>选项，且保证密码一致才能通过验证</p><p>4）身份验证完成之后，从服务器会发送自己的监听端口，主服务器会保存下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.249.20:6379&gt; info replication</span><br><span class="line">...</span><br><span class="line">slave0:ip=192.168.249.22,port=6379,state=online,offset=700,lag=0</span><br><span class="line">slave1:ip=192.168.249.21,port=6379,state=online,offset=700,lag=0</span><br><span class="line">...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>在主从服务器建立连接确认各自身份之后，就开始数据同步，从服务器向主服务器发送<code>PSYNC</code>命令，执行同步操作，并把自己的数据库状态更新至主服务器的数据库状态</p><p>Redis的主从同步分为：<strong>完整重同步（full resynchronization）和部分重同步（partial resynchronization）</strong></p><h5 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h5><p>有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候有可能是完整重同步，这个在后面说</p><p>下面是完整重同步的步骤</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3ea1dbeb04fc9?imageslim" alt="img"></p><ul><li>从服务器连接主服务器，发送SYNC命令</li><li>主服务器接收到SYNC命名后，开始执行<code>bgsave</code>命令生成RDB文件并使用缓冲区记录此后执行的所有写命令</li><li>主服务器<code>bgsave</code>执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令</li><li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照</li><li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令</li><li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令</li></ul><h5 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h5><p>部分重同步是用于处理断线后重复制的情况，先介绍几个用于部分重同步的部分</p><ul><li><code>runid</code>(replication ID)，主服务器运行id，Redis实例在启动时，随机生成一个长度40的唯一字符串来标识当前节点</li><li><code>offset</code>，复制偏移量。主服务器和从服务器各自维护一个复制偏移量，记录传输的字节数。当主节点向从节点发送N个字节数据时，主节点的offset增加N，从节点收到主节点传来的N个字节数据时，从节点的offset增加N</li><li><code>replication backlog buffer</code>，复制积压缓冲区。是一个固定长度的FIFO队列，大小由配置参数<code>repl-backlog-size</code>指定，默认大小1MB。需要注意的是该缓冲区由master维护并且有且只有一个，所有slave共享此缓冲区，其作用在于备份最近主库发送给从库的数据</li></ul><p>当slave连接到master，会执行<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>发送记录旧的master的<code>runid</code>（replication ID）和偏移量<code>offset</code>，这样master能够只发送slave所缺的增量部分。但是如果master的复制积压缓存区没有足够的命令记录，或者slave传的<code>runid</code>(replication ID)不对，就会进行<strong>完整重同步</strong>，即slave会获得一个完整的数据集副本</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3ea1dbf509bd1?imageslim" alt="img"></p><p>PSYNC命令执行完整重同步和部分重同步的流程图</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/17/16d3ea1dc026aea7?imageslim" alt="img"></p><h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令</p><p>在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送<strong>心跳检测</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中<code>replication_offset</code>是当前从服务器的复制偏移量，该命令的作用有三个</p><ul><li>检测主从服务器的网络连接状态</li><li>辅助实现<code>min-slaves</code>选项</li><li>检测命令丢失</li></ul><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p><ol><li>每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?imageslim" alt="img"></p><ol start="2"><li>如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?imageslim" alt="img"></p><ol start="3"><li>如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?imageslim" alt="img"></p><ol start="4"><li>如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?imageslim" alt="img"></p><ol start="5"><li>在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?imageslim" alt="img"></p><ol start="6"><li><code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?imageslim" alt="img"></p><ol start="7"><li>当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?imageslim" alt="img"></p><blockquote><p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p></blockquote><h4 id="Master选举策略"><a href="#Master选举策略" class="headerlink" title="Master选举策略"></a>Master选举策略</h4><p>redis2.8.7的选举有两个条件，首先是要下面的条件过滤掉一些节点</p><p>一、使用如下条件筛选备选node：</p><p>1、slave节点状态处于S_DOWN,O_DOWN,DISCONNECTED的除外</p><p>2、最近一次ping应答时间不超过5倍ping的间隔（假如ping的间隔为1秒，则最近一次应答延迟不应超过5秒，redis sentinel默认为1秒）</p><p>3、info_refresh应答不超过3倍info_refresh的间隔（原理同2,redis sentinel默认为10秒）</p><p>4、slave节点与master节点失去联系的时间不能超过（ (now - master-&gt;s_down_since_time) + (master-&gt;down_after_period * 10)）。总体意思是说，slave节点与master同步太不及时的（比如新启动的节点），不应该参与被选举。</p><p>5、Slave priority不等于0（这个是在配置文件中指定，默认配置为100）。</p><p>二、从备选node中，按照如下顺序选择新的master</p><p>1、较低的slave_priority（这个是在配置文件中指定，默认配置为100）</p><p>2、较大的replication offset（每个slave在与master同步后offset自动增加）</p><p>3、较小的runid（每个redis实例，都会有一个runid,通常是一个40位的随机字符串,在redis启动时设置，重复概率非常小）</p><p>4、如果以上条件都不足以区别出唯一的节点，则会看哪个slave节点处理之前master发送的command多，就选谁。</p><p>###集群</p><h3 id="Redis主从结构的持久化"><a href="#Redis主从结构的持久化" class="headerlink" title="Redis主从结构的持久化"></a><a href="https://zhuanlan.zhihu.com/p/68402040" target="_blank" rel="noopener">Redis主从结构的持久化</a></h3><ul><li>Master关闭持久化：RDB持久化需要调用<code>fork()</code>函数构建子进程进行持久化。在这个过程中，父进程会阻塞，影响性能；AOF rewrite也会造成同样结果</li><li>Slave开RDB，必要时开启AOF</li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>###SETNX</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// value值是当前时间加过期时间的时间戳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(redisTemplate.opsForValue.setIfAbsent(key,value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String currentValue = redisTemplate.opsForValue.get(key);</span><br><span class="line">        <span class="comment">// 若当前时间大于时间戳，则进入锁抢占</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(currentValue) &amp;&amp; Long.parseLong(currentValue)&lt;System.currentTimeMillis)) &#123;</span><br><span class="line">            <span class="comment">// 多个线程进行getset操作，仅有一个获得oldValue==currentValue</span></span><br><span class="line">            String oldValue = redisTemplate.opsForValue().getAndSet(key,value);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.isEmpty(oldValue) &amp;&amp; oldValue.equals(currentValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key,String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String currentValue = redisTemplate.opsForValue().get(key);</span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(currentValue) &amp;&amp; currentValue.equals(value)) &#123;</span><br><span class="line">                redisTemplate.opsForValue().getOperations().delete(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SellException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不推荐原因：</p><p>1.根据流程图可看出其流程较为繁琐</p><p>2.使用较为老式的 setnx方法获取锁及expire方法（无法保证原子操作）</p><p>3.redis单点，无法做到错误兼容性；</p><p>更好的方法：<strong>加锁和解锁使用lua脚本保证原子性（redis保证执行此脚本时不执行其他操作）。</strong></p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是Java的redis客户端之一。</p><p>实现锁主要用到的是RedissonLock这个类，其加锁/释放锁都是用lua脚本完成的。</p><h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a><a href="https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html" target="_blank" rel="noopener">RedLock</a></h3><p><strong>RedLock</strong>并非一个工具，而是Redis官方提出的一种<strong>分布式锁</strong>的算法。</p><p>这个锁的算法实现了多Redis实例的情况。相对于单Redis节点来说，防止了单节点鼓掌造成整个服务停止运行的情况。</p><p><strong>最低保证分布式锁的有效性及安全性的要求如下：</strong></p><p>1.互斥：任何时刻只能有一个client获取锁</p><p>2.释放死锁：即使锁定资源的服务崩溃或者分区，仍然能释放锁</p><p>3.容错性：只要多数redis节点（一半以上）在使用，client就可以获取和释放锁</p><p>为了取到锁，客户端应该执行以下操作:</p><ul><li>获取当前Unix时间，以毫秒为单位。</li><li>依次尝试从5个实例，使用相同的key和<strong>具有唯一性的value</strong>（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。<strong>当且仅当从大多数</strong>（N/2+1，这里是3个节点）<strong>的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="${}和#{}的区别"></a><code>${}</code>和<code>#{}</code>的区别</h2><p><code>#{}</code>能够有效防止sql注入。</p><p>使用参数符号#的句子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id="selectPerson" parameterType="int" resultType="hashmap"&gt;</span><br><span class="line">  <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PERSON <span class="keyword">WHERE</span> <span class="keyword">ID</span> = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>MyBatis会创建一个预编译语句，生成的代码类似于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar JDBC code, NOT MyBatis…</span></span><br><span class="line">String selectPerson = <span class="string">"SELECT * FROM PERSON WHERE ID=?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure><p>参数会在SQL语句中用占位符”?”来标识，然后使用prepareStatement来预编译这个SQL语句。</p><p>prepareStatement通过把用户非法输入的单引号用\反斜杠转义来防止sql注入。</p><h2 id="Mapper原理"><a href="#Mapper原理" class="headerlink" title="Mapper原理"></a>Mapper原理</h2><p><a href="https://www.cnblogs.com/hopeofthevillage/p/11384848.html" target="_blank" rel="noopener">Mybatis mapper动态代理的原理详解</a></p><ul><li><p>解析XML： 初始化SqlSessionFactoryBean会将mapperLocations路径下所有的XML文件进行解析</p><ul><li>创建SqlSource： Mybatis会把每个SQL标签封装成SqlSource对象，可以为动态SQL和静态SQL</li><li>创建MappedStatement： XML文件中的每一个SQL标签就对应一个MappedStatement对象 ，并由 Configuration解析XML</li></ul></li><li><p>Dao接口代理：  Spring中的FactoryBean 和 JDK动态代理返回了可以注入的一个Dao接口的代理对象</p></li><li><p>执行： 通过statement全限定类型+方法名拿到MappedStatement 对象，然后通过执行器Executor去执行具体SQL并返回</p></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p><a href="https://juejin.im/post/6844903920599302152" target="_blank" rel="noopener">单例模式双重检查锁对实例的volatile</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> **<span class="keyword">volatile</span>** <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton = <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不对singleton使用<code>volatile</code>关键字，则可能造成Null Pointer Exception.</p><p>原因：<code>singleton = new Singleton()</code>并非原子操作。其大致可分为三个步骤：</p><ol><li>JVM为对象分配一块内存M</li><li>在内存M上为对象进行初始化</li><li>将内存M的地址复制给singleton变量</li></ol><p>执行步骤3的时候会使<code>if (singleton == null)</code>判断为false。若发生重排，则会在初始化之前就返回了该对象，造成NPE。具体volatile如何禁止指令重排见<a href="#volatile">Volatile的语义</a></p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote><p><a href="https://juejin.im/entry/6844903474639929357" target="_blank" rel="noopener">工厂模式详解</a></p></blockquote><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类Movie</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现类HorrorMovie/Documentary/Comedy...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorrorMovie</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        playHorror();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span> <span class="keyword">implements</span> <span class="title">Movie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movie realMovie;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(Movie movie)</span> </span>&#123;</span><br><span class="line">        realMovie = movie;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        realMovie.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Movie realMovie = <span class="keyword">new</span> HorrorMovie();</span><br><span class="line">        Cinema cinema = <span class="keyword">new</span> Cinema(realMovie);</span><br><span class="line">        cinema.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Cinema implements InvocationHandler &#123;</span><br><span class="line">    <span class="keyword">private</span> Object thingCanPlay;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">(Object thing)</span> </span>&#123;</span><br><span class="line">        thingCanPlay = thing;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        thingsBeforePlay();</span><br><span class="line">        method.invoke(thingCanPlay);</span><br><span class="line">        thingsAfterPlay();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HorrorMovie horrorMovie = <span class="keyword">new</span> HorrorMovie();</span><br><span class="line">        InvocationHandler cinema = <span class="keyword">new</span> Cinema(horrorMovie);</span><br><span class="line">        Movie dynamicProxy = (Movie) Proxy.newProxyInstance(HorrorMovie<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">HorrorMovie</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">cinema</span>)</span>;</span><br><span class="line">      <span class="comment">//newProxyInstance的三个参数分别为(loader类加载器,interfaces代理的接口,IH对象)</span></span><br><span class="line">        dynamicProxy.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p>##(TODO) 一致性Hash</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote><p>分布式事务不可能同时满足一致性(Consistency)、可用性(Availability)和分区容忍性(Partition Tolerance)，最多只能同时满足其中两项。</p><p>​                                                                                                                                                                                                                            —— CAP理论</p></blockquote><p>一致性： 指的是doge数据副本能否保持一致的特性。在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><p>可用性： 指的是分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量。在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><p>分区容忍性： 分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><p><strong><em>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和 一致性之间做权衡。</em></strong></p><hr><p><a href="https://www.cnblogs.com/qdhxhz/p/11167025.html" target="_blank" rel="noopener">关于2PC/3PC，详见这篇文章</a></p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交又称<strong>2PC</strong>,2PC是一个非常经典的<code>强一致、中心化的原子提交协议</code>。</p><p>这里所说的中心化是指协议中有两类节点：一个是中心化<code>协调者节点</code>（coordinator）和<code>N个参与者节点</code>（partcipant）。</p><p><code>两个阶段</code>：第一阶段：<strong>投票阶段</strong> 和第二阶段：<strong>提交/执行阶段</strong>。</p><p><code>举例</code> <strong>订单服务A</strong>，需要调用 <strong>支付服务B</strong> 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。</p><h4 id="2PC缺点"><a href="#2PC缺点" class="headerlink" title="2PC缺点"></a>2PC缺点</h4><p>通过上面的演示，很容易想到2pc所带来的缺陷</p><p>1）<code>性能问题</code></p><p>无论是在第一阶段的过程中,还是在第二阶段,<strong>所有的参与者资源和协调者资源都是被锁住的</strong>,只有当所有节点准备完毕，事务 <strong>协调者</strong> 才会通知进行全局提交，</p><p><strong>参与者</strong> 进行本地事务提交后才会释放资源。这样的<strong>过程会比较漫长，对性能影响比较大</strong>。</p><p>2）<code>单节点故障</code></p><p>由于<strong>协调者</strong>的重要性，一旦 <strong>协调者</strong> 发生故障。<strong>参与者</strong> 会一直阻塞下去。尤其在第二阶段，<strong>协调者</strong> 发生故障，那么所有的 <strong>参与者</strong> 还都处于</p><p>锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p><strong>2PC出现单点问题的三种情况</strong></p><p>(1)<code>协调者正常,参与者宕机</code></p><p> 由于 <strong>协调者</strong> 无法收集到所有 <strong>参与者</strong> 的反馈，会陷入阻塞情况。</p><p> <strong>解决方案</strong>:引入超时机制,如果协调者在超过指定的时间还没有收到参与者的反馈,事务就失败,向所有节点发送终止事务请求。</p><p>(2)<code>协调者宕机,参与者正常</code></p><p> 无论处于哪个阶段，由于<strong>协调者宕机</strong>，无法发送提交请求，所有处于执行了操作但是未提交状态的参与者都会陷入阻塞情况.</p><p> <strong>解决方案</strong>:引入协调者备份,同时协调者需记录操作日志.当检测到协调者宕机一段时间后，协调者备份取代协调者，并读取操作日志，向所有参与者询问状态。</p><p>(3)<code>协调者和参与者都宕机</code></p><ol><li><strong>发生在第一阶段</strong>： 因为第一阶段，所有参与者都没有真正执行commit，所以只需重新在剩余的参与者中重新选出一个协调者，新的协调者在重新执行第一阶段和第二阶段就可以了。</li><li><strong>发生在第二阶段 并且 挂了的参与者在挂掉之前没有收到协调者的指令</strong>。也就是上面的第4步挂了，这是可能协调者还没有发送第4步就挂了。这种情形下，新的协调者重新执行第一阶段和第二阶段操作。</li><li><strong>发生在第二阶段 并且 有部分参与者已经执行完commit操作</strong>。就好比这里订单服务A和支付服务B都收到<strong>协调者</strong> 发送的commit信息，开始真正执行本地事务commit,但突发情况，Acommit成功，B确挂了。这个时候目前来讲数据是不一致的。虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！ 2PC 无法解决这个问题。</li></ol><p>###3PC </p><p>三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞。三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、引入超时机制。同时在协调者和参与者中都引入超时机制。</span><br><span class="line">2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</span><br></pre></td></tr></table></figure><p>也就是说，除了引入超时机制之外，<strong>3PC把2PC的准备阶段再次一分为二</strong>，这样三阶段提交就有<code>CanCommit</code>、 <code>PreCommit</code>、 <code>DoCommit</code>三个阶段。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>##循环依赖</p><p>Spring解决循环依赖，本质上是利用以下两点：</p><ol><li>利用缓存识别已经遍历过的节点；</li><li>利用Java引用，先设置对象地址，后完善bean。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">singletonObjects; <span class="comment">// 存放以实例化的bean</span></span><br><span class="line">singletonFactories; <span class="comment">// 存放正在实例化的bean</span></span><br><span class="line">earlySingletonObjects; <span class="comment">// 存放实例化不完全的bean</span></span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000023647227" target="_blank" rel="noopener"><strong>循环依赖和三级缓存（为什么不使用二级缓存？）</strong></a></p><p>##(TODO) IOC和AOP</p><h2 id="Spring实例化bean"><a href="#Spring实例化bean" class="headerlink" title="Spring实例化bean"></a>Spring实例化bean</h2><ol><li>从 xml 配置文件获取 Bean 信息：id、全限定名，将其作为 BeanDefinition（Bean 定义类）的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinition bd = <span class="keyword">new</span> BeanDefinition(id, beanClassName);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用一个 Map 存放所有 BeanDefinition，此时 Spring 本质上是一个 Map，存放 BeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>当获取 Bean 实例时，通过类加载器，根据全限定名，得到其类对象，通过类对象利用<strong>反射</strong>创建 Bean 实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Thread.currentThread().getContextClassLoader().loadClass(bd.getBeanClassName()).newInstance();</span><br></pre></td></tr></table></figure><h3 id="依赖注入DI"><a href="#依赖注入DI" class="headerlink" title="依赖注入DI"></a>依赖注入DI</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.deppwang.litespring.v2.service.PetStoreService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据<code>&lt;constructor-arg&gt;</code>来实现依赖注入。大致分为以下三步：</p><ol><li><p>从 xml 中获取构造函数的参数实例的 id，存放到 BeanDefinition 的 constructorArguments 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bd.getConstructorArgumentValues().add(argumentName);</span><br></pre></td></tr></table></figure></li><li><p>通过反射得到 PetStoreService 所有的构造函数（Constructor 对象），找到参数跟 constructorArguments 一致的 Constructor 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] candidates = beanClass.getDeclaredConstructors();</span><br></pre></td></tr></table></figure></li><li><p>通过 constructorArguments 获取到所有参数实例，再利用反射，通过 Constructor 对象实现填充属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> constructorToUse.newInstance(argsToUse);</span><br></pre></td></tr></table></figure></li></ol><p>##(TODO) Bean的生命周期</p><blockquote><p> Spring 只帮我们管理单例模式 Bean 的<strong>完整</strong>生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><p>##BeanFactory和FactoryBean</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p><strong>即Bean工厂。</strong>包括XmlBeanFactory, DefaultListableBeanFactory, ApplicationContext等。完成Bean的创建和自动装配，存储单例Bean。</p><ul><li>如果使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时候实例化 （不管bean是否实现了FactoryBean）</li><li>如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况：<br>（1）：如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取 （但是如果bean实现了FactoryBean，则ApplicationContext启动的时候先实例化对应的FactoryBean，当第一次使用bean的时候，在通过FactoryBean的getObject方法实例化bean）<br>（2）：如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化<br>（3）：如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 资源加载</span></span><br><span class="line">   <span class="comment">// 调用资源加载器加载Spring配置文件</span></span><br><span class="line">PathMatchingResourcePatternResolver resolver=<span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">Resource res =resolver.getResource(<span class="string">"classpath:/application.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建默认Spring提供的BeanFactory实现类</span></span><br><span class="line">DefaultListableBeanFactory bf =<span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanDefinition 读取器,专门读取资源到容器</span></span><br><span class="line">XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(bf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取资源进到容器 </span></span><br><span class="line">reader.loadBeanDefinitions(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时容器初始化完毕后可以取里面的bean了.</span></span><br><span class="line">bf.getBean(<span class="string">"..."</span>);</span><br></pre></td></tr></table></figure><p>其中<code>DefaultListableBeanFactory</code>相当于一个简单工厂。</p><p>或使用<code>ApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac =<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br><span class="line">ApplicationContext ac =<span class="keyword">new</span> FileSystemXmlApplicationContext(/User/Desktop/application.xml);</span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a><a href="https://juejin.im/post/6844903954615107597" target="_blank" rel="noopener">FactoryBean</a></h3><p>Spring 为了使用不同的方式均可实现实例化 Bean，不能只是简单工厂，需要使用工厂方法模式。如果一个bean的创建过程中涉及到很多其他的bean和复杂的逻辑，用xml配置困难，这时可以考虑用FactoryBean</p><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d72cab4c659a1b?imageslim" alt="img"></p><h3 id="TODO-FactoryBean相较BeanFactory的优势"><a href="#TODO-FactoryBean相较BeanFactory的优势" class="headerlink" title="(TODO) FactoryBean相较BeanFactory的优势"></a>(TODO) FactoryBean相较BeanFactory的优势</h3><h2 id="注解的实现"><a href="#注解的实现" class="headerlink" title="注解的实现"></a>注解的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Override的定义</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是一个继承了Annotation接口的接口。<strong><code>@Target</code></strong>和<strong><code>@Retention</code></strong>为元注解，可以用元注解来定义自己的注解。</p><p>解析一个类或方法的注解有两种形式：<strong>编译器扫描</strong>和<strong>运行期反射</strong></p><hr><p>例子：自定义注解+拦截器实现登陆校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoginRequired注解定义</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoginRequired &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的登陆模拟，在访问/sourceB时需要登录验证</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sourceA"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sourceA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你正在访问sourceA资源"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoginRequired</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/sourceB"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sourceB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你正在访问sourceB资源"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceAccessInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入拦截器了"</span>);</span><br><span class="line"><span class="comment">// 反射获取方法上的LoginRequred注解</span></span><br><span class="line">        <span class="comment">// ******************</span></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod)handler;</span><br><span class="line">        LoginRequired loginRequired = handlerMethod.getMethod().getAnnotation(LoginRequired<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(loginRequired == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有LoginRequired注解说明需要登录，提示用户登录</span></span><br><span class="line">        response.setContentType(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">"你访问的资源需要登录"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建配置类将添加拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorTrainConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> SourceAccessInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Springboot启动流程"><a href="#Springboot启动流程" class="headerlink" title="Springboot启动流程"></a><a href="https://www.wwwbuild.net/javaxxf/12004.html" target="_blank" rel="noopener">Springboot启动流程</a></h2><blockquote><p><a href="https://www.processon.com/view/link/59812124e4b0de2518b32b6e" target="_blank" rel="noopener">SpringBoot启动结构图</a></p></blockquote><p>SpringBoot启动的时候，不论调用什么方法，都会构造一个SpringApplication的实例，然后调用这个实例的run方法，这样就表示启动SpringBoot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SellApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个合成体。最重要的三个注解</p><p><strong><code>@SpringBootConfiguration</code></strong>配置类</p><p><strong><code>@EnableAutoConfiguration</code></strong>从 ClassPath下扫描所有的 META-INF/spring.factories 配置文件，并将spring.factories 文件中满足<code>@ConditionOnClass</code>的 EnableAutoConfiguration 对应的配置项通过反射机制实例化为对应标注了 @Configuration 的形式的IoC容器配置类，然后注入IoC容器。</p><p><strong><code>@ComponentScan</code></strong>将一些标注了特定注解的bean(如@Controller…)定义批量采集注册到Spring的IoC容器之中</p><p>###SpringApplication.<em>run</em>()</p><ol><li><p>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListeners</code> 对象</p></li><li><p>然后由 <code>SpringApplicationRunListeners</code> 来发出 starting 消息</p></li><li><p>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</p></li><li><p>完成之后，依然由 <code>SpringApplicationRunListeners</code> 来发出 environmentPrepared 消息</p></li><li><p>创建 <code>ApplicationContext</code></p></li><li><p>初始化 <code>ApplicationContext</code>，并设置 Environment，加载相关配置等</p></li><li><p>由 <code>SpringApplicationRunListeners</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</p></li><li><p>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListeners</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</p></li><li><p>refresh ApplicationContext，完成IoC容器可用的最后一步</p></li><li><p>由 <code>SpringApplicationRunListeners</code> 来发出 started 消息</p></li><li><p>完成最终的程序的启动</p></li><li><p>由 <code>SpringApplicationRunListeners</code> 来发出 running 消息，告知程序已运行起来了</p></li></ol><h2 id="Bean相关"><a href="#Bean相关" class="headerlink" title="Bean相关"></a>Bean相关</h2><p><a href="https://juejin.im/post/6844904131803480077#heading-4" target="_blank" rel="noopener">实现简易Spring</a></p><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote><p>worker_connections are not enough。 解决方法：修改nginx配置文件的worker_connections参数</p><p>502: no live upstreams while connecting to upstream。解决方法：使用HTTP1.1，keepalive加大：设置到upstream服务器的空闲keepalive连接的最大数量</p></blockquote><h2 id="Epoll多路复用"><a href="#Epoll多路复用" class="headerlink" title="Epoll多路复用"></a>Epoll多路复用</h2><ul><li>Java BIO模型，阻塞进程式</li><li>Linux select模型，变更出发轮询查找，有1024数量上限/轮询O(n)</li><li>epoll模型，变更触发回调直接读取，理论上无上限</li></ul><hr><h2 id="Master-Worker进程模式"><a href="#Master-Worker进程模式" class="headerlink" title="Master-Worker进程模式"></a>Master-Worker进程模式</h2><p>Nginx首先创建master进程，通过<strong><code>socket()</code></strong>创建一个sockfd用于监听指定端口(80或443)；</p><p>接下来通过<strong><code>fork()</code></strong>创建多个worker子进程（worker的数量一般和cpu数量相等，以避免上下文切换），此时所有worker进程继承了sockfd描述符。</p><h3 id="惊群现象"><a href="#惊群现象" class="headerlink" title="惊群现象"></a>惊群现象</h3><blockquote><p><a href="https://blog.csdn.net/dog250/article/details/80837278" target="_blank" rel="noopener">再谈Linux epoll惊群问题的原因和解决方案</a></p><p><a href="https://jin-yang.github.io/post/linux-details-of-thundering-herd.html" target="_blank" rel="noopener">Linux 惊群详解</a></p></blockquote><p>当有新的连接请求时，所有子进程都会抢着与该请求建立连接，这被称作<strong>accept惊群</strong>。Linux已经解决了该问题。当多个进程/线程都阻塞在对同一个 socket 的 accept 调用上时，当有一个新的连接到来，内核只会唤醒一个进程，其他进程保持休眠，不会被唤醒。</p><p>Nginx采用epoll事件模型处理连接。主进程执行 <code>socket()+bind()+listen()</code> 后，将该 socket 加入到 epoll 中，然后 fork 出多个子进程，每个进程都阻塞在 <code>epoll_wait()</code> 上，如果有事件到来，则判断该事件是否是该 socket 上的事件，如果是，说明有新的连接到来了，则进行 accept 操作。由于内核不知道对应的触发事件具体由哪些进程处理，所有的进程都会被唤醒，这被称作<strong>epoll惊群</strong>。</p><p>为解决惊群现象带来的资源浪费，nginx设置了一个<strong><code>accept-mutex</code></strong>惊群锁，只有获得锁的进程才能监听端口。</p><hr><h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p><strong>1、轮询法</strong></p><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><p><strong>2、加权轮询法</strong></p><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><p><strong>3、随机法</strong></p><p>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，</p><p>其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p><p><strong>4、加权随机法</strong></p><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><p><strong>5、哈希算法</strong></p><ul><li>普通哈希：源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li><li>一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。一致性hash算法就是把每台server分成v个虚拟节点，再把所有虚拟节点（n*v）随机分配到一致性哈希的圆环上，这样所有的用户从自己圆环上的位置顺时针往下取到第一个vnode就是自己所属的节点。当此节点存在故障时，再顺时针取下一个作为替代节点</li></ul><p><strong>6、最小连接数法</strong></p><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前</p><p>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><p><strong>7、IP地址散列</strong></p><p>通过管理发送方IP和目的地IP地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处理。</p><p><strong>8、URL散列</strong></p><p>通过管理客户端请求URL信息的散列，将发送至相同URL的请求转发至同一服务器的算法。</p><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="内嵌配置"><a href="#内嵌配置" class="headerlink" title="内嵌配置"></a>内嵌配置</h3><ul><li>server.tomcat.accept-count : 等待队列长度，默认100</li><li>server.tomcat.max-connection：最大可被连接数，默认10000</li><li>server.tomcat.max-threads：最大工作线程数，默认200</li><li>server.tomcat.min-spare-threads：最小工作线程数，默认10</li></ul><blockquote><p>4核8G单进程调度线程数800-1000以上后话费巨大的时间在cpu调度上</p><p>等待队列长度不能过长，消耗内存，出队入队消耗cpu</p></blockquote><p>![image-20200715145603609](/Users/silverlining/Library/Application Support/typora-user-images/image-20200715145603609.png)</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="分布式会话要解决的问题"><a href="#分布式会话要解决的问题" class="headerlink" title="分布式会话要解决的问题"></a>分布式会话要解决的问题</h3><ul><li>Tomcat提供的Session迁移到Redis：默认的session由tomcat提供，session在不同服务器上无法互通</li><li>Cookie由token代替：为不同终端设备考虑</li></ul><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><ul><li>用快速存取设备——内存</li><li>将缓存推到离用户最近的地方</li><li>脏缓存清理</li></ul><h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><ol><li><p>redis缓存 (集中式缓存中间件、NOSQL数据库、易失)</p><ul><li>单机版（稳定问题、容量上限)</li><li>Sentinel 哨兵模式 （容量上限）</li><li>集群cluster模式</li></ul></li><li><p>热点内存本地缓存</p><ul><li>热点数据</li><li>脏读非常不敏感</li><li>内存可控</li></ul><p>Guava cache: 可控制的大小和超时时间、可配置的LRU策略、线程安全</p></li><li><p>nginx proxy cache缓存 </p><ul><li>nginx反向代理前置</li><li>依靠文件系统存索引级的文件</li><li>依靠内存缓存文件地址</li></ul><p>由于还是要到本地磁盘中读取缓存文件，性能反而不如之前</p></li><li><p>nginx lua缓存</p><ul><li>lua<a href="https://www.jianshu.com/p/cb1f67c4a97c" target="_blank" rel="noopener">协程机制</a></li></ul><p>Openresty实践</p><ul><li>shared dic:共享内存字典，所有worker进程可见，支持LRU淘汰</li><li>redis支持</li><li>先在shared dic查，再到redis查？</li></ul></li></ol><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>有一种方案：ReadWriteLock 读写分离，jdk源码有个例子； 大概原理就是所有请求进来都申请一个读锁，当发现没有数据时升级为写锁（先释放读锁再去申请，只会有一个能升级成功），其他的请求就会等待持有写锁的那个去db拿数据…</p><p>另一种方法：使用ReentrantLock。多个线程获取缓存失败时同时使用lock.tryLock()请求锁，一个线程抢占并将数据库写入缓存，其他线程使用sleep后重新请求缓存。</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>解决方法：</p><ul><li>事前：尽量保证整个redis集群的高可用性</li></ul><h3 id="数据库和缓存双写一致性方案"><a href="#数据库和缓存双写一致性方案" class="headerlink" title="数据库和缓存双写一致性方案"></a>数据库和缓存双写一致性方案</h3><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。主要有三种更新策略：</p><ol><li><p>先更新数据库，再更新缓存</p><p>通常反对。两个原因：</p><p>首先是线程安全角度。考虑请求A和请求B同时更新，则</p><ul><li>线程A更新数据库</li><li>线程B更新数据库</li><li>线程B更新缓存</li><li>线程A更新缓存</li></ul><p>则会导致脏数据。</p><p>其次是业务场景角度。若是写多读少的场景，则会导致不必要的缓存刷新。</p></li></ol><p>   <strong><em>然而在秒杀项目中，线程安全，可以用分布式锁解决。秒杀场景下库存刷新是必要的，故选择此方案。</em></strong></p><ol start="2"><li><p>先删除缓存，再更新数据库</p><p>会导致不一致：同时有一个请求A进行更新操作，另一个请求B进行查询操作，则：</p><ul><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ul><p>则会导致不一致出现。</p></li><li><p>先更新数据库，再删除缓存(Cache-Aside Pattern)</p></li></ol><h3 id="交易验证优化"><a href="#交易验证优化" class="headerlink" title="交易验证优化"></a>交易验证优化</h3><h4 id="用户风控策略优化：商品及用户信息缓存"><a href="#用户风控策略优化：商品及用户信息缓存" class="headerlink" title="用户风控策略优化：商品及用户信息缓存"></a>用户风控策略优化：商品及用户信息缓存</h4><h4 id="活动校验策略优化：异步同步数据库"><a href="#活动校验策略优化：异步同步数据库" class="headerlink" title="活动校验策略优化：异步同步数据库"></a>活动校验策略优化：异步同步数据库</h4><ol><li><p>活动发布同步库存进缓存</p><p>针对活动开始前的库存不稳定状态，可采取活动前五分钟下架商品的方法</p></li><li><p>下单交易减缓存库存</p></li><li><p>异步消息扣减数据库内库存</p></li></ol><ul><li><p>下单前扣件redis库存，若库存不够直接抛出异常；在下单所有操作都完成之后进行异步扣减库存，若MQ发送失败则将redis库存加回并抛出异常。<strong>但此处1.可能redis补回失败，并未处理；2.可能由于网络原因事物commit失败，但MQ消息已经发送，数据库和redis库存被扣减</strong>；</p></li><li><p>针对上面的<em>2</em>使用Spring中<code>TransactionSynchronizationManager.registerSynchronization</code>的<code>afterCommit</code>方法，可以在事物提交后再进行异步消息的发送。<strong>但此处一旦发生异常消息即遭到浪费</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止由于网络原因造成事物commit失败引起库存浪费</span></span><br><span class="line"><span class="comment">// 事物提交后执行</span></span><br><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 事物提交后执行</span></span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但该方法无法在MQ失败的情况下异步回滚库存</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="事物型消息"><a href="#事物型消息" class="headerlink" title="事物型消息"></a>事物型消息</h3><blockquote><p>事物型消息：只要数据库数据提交，消息必定发送成功；只要数据库回滚，消息必定不发送</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">transactionalMQProducer.setTransactionListener(<span class="keyword">new</span> TransactionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message message, Object args)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 此处是真正要做的事</span></span><br><span class="line">                Integer itemId = (Integer)((Map)args).get(<span class="string">"itemId"</span>);</span><br><span class="line">                Integer promoId = (Integer)((Map)args).get(<span class="string">"promoId"</span>);</span><br><span class="line">                Integer userId = (Integer)((Map)args).get(<span class="string">"userId"</span>);</span><br><span class="line">                Integer amount = (Integer)((Map)args).get(<span class="string">"amount"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    orderService.createOrder(userId,itemId,promoId,amount);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BusinessException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 根据是否扣减库存成功，来判断要返回COMMIT,ROLLBACK还是继续UNKNOW</span></span><br><span class="line">                String jsonString = <span class="keyword">new</span> String(messageExt.getBody());</span><br><span class="line">                Map&lt;String,Object&gt; map = JSON.parseObject(jsonString, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Integer itemId = (Integer) map.get(<span class="string">"itemId"</span>);</span><br><span class="line">                Integer amount = (Integer) map.get(<span class="string">"amount"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>事务性消息有二阶段提交的概念。消息发送后，MessageBroker收到的消息为prepare的状态，此时消息对消费者不可见，而是执行<code>executeLocalTransaction</code>方法（项目中为<code>createOrder</code>。</p><h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><ol><li>RocketMQ提供了类似X/Open XA的分布事务功能，通过MQ的事务消息能达到分布式事务的最终一致。</li><li>发送方在业务执行开始会先向<a href="https://cloud.tencent.com/product/cmq?from=10680" target="_blank" rel="noopener">消息队列</a>中投递 <strong>“半消息”</strong> ，半消息即暂时不会真正投递的消息，当发送方（即生产者）将消息成功发送给了MQ服务端且并未将该消息的二次确认结果返回，此时消息状态是“暂时不可投递”状态（可以认为是状态未知）。该状态下的消息即半消息。</li><li>如果出现网络闪断、生产者应用重启等原因导致事务消息二次确认丢失，MQ服务端会通过扫描发现某条消息长期处于 <strong>“半消息”</strong> 状态，MQ服务端会主动向生产者查询该消息的最终状态是处于Commit(消息提交)还是Rollback(消息回滚)。这个过程称为消息回查。</li></ol><p><strong>有了上述的概念，我们详细解释一下事务消息交互的过程。</strong></p><ol><li>首先，MQ发送方向MQ服务（即RocketMQ的Broker）发送半消息。</li><li>MQ服务端会将消息做持久化处理，并发送ACK确认消息已经发送成功。</li><li>MQ发送方执行本地事务</li><li>MQ发送方根据本地事务执行的结果向MQ服务提交二次确认：如果本地事务执行成功，则提交消息状态为Commit，否则为Rollback。MQ服务端收到Commit状态的消息将消息标记为可投递状态，订阅方最终会收到该条消息。如果收到的是Rollback，最终MQ服务端会删除该条半消息，订阅方不会接收到这条消息。</li><li>如果出现网络闪断、应用重启等情况，4阶段替提交的二次确认最终并未能到达MQ服务端，一定时间之后，MQ服务端会对此消息发起回查操作，确认发送方本地事务的执行状态。</li><li>发送方需要实现服务回查逻辑供MQ服务端进行回调。当发送方收到回查后，需要检查对应消息的本地事务执行的最终结果，此处也需要根据本地事务的成功或失败返回Commit或者Rollback，即再次提交消息状态的二次确认，MQ服务端仍会按照步骤4对该半消息进行操作。</li></ol><p><strong>考虑在上方代码处，若执行到<code>createOrder</code>时网络出错，没有返回值怎么办？</strong></p><p>此时需要用到<code>checkLocalTransaction</code>方法。在<code>LocalTransactionState</code>状态为UNKNOW或长时间不返回时执行。</p><p>需要库存流水以match到对应订单</p><h4 id="事务性消息模块整体逻辑"><a href="#事务性消息模块整体逻辑" class="headerlink" title="事务性消息模块整体逻辑"></a>事务性消息模块整体逻辑</h4><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><strong>存在问题：</strong></p><ol><li>秒杀下单接口会被脚本不停的刷</li><li>秒杀验证（用户）逻辑和秒杀下单接口强关联，代码冗余度高</li><li>秒杀验证逻辑复杂，产生无关负载</li></ol><h4 id="秒杀令牌"><a href="#秒杀令牌" class="headerlink" title="秒杀令牌"></a>秒杀令牌</h4><ul><li>秒杀接口需要令牌才能进入</li><li>秒杀令牌由秒杀活动模块全权处理</li><li>秒杀下单前需先获得秒杀令牌</li></ul><p><strong>将验证用户信息、商品信息均移至获得令牌的<code>generateToken()</code>接口中【解耦】</strong></p><p><code>createOrder()</code>时，若redis内令牌和参数传入令牌不符，则拒绝下单请求。</p><p><strong>目前逻辑</strong> 下单click操作时，将promoId和itemId通过POST操作由ajax请求跳转至<code>generateToken()</code>方法，若返回状态为success，再通过ajax跳转至<code>createOrder()</code>方法下单。</p><p><strong>存在问题</strong> 秒杀令牌无限生成，消耗系统性能，且并非所有人都有下单机会。</p><h4 id="秒杀大闸"><a href="#秒杀大闸" class="headerlink" title="秒杀大闸"></a>秒杀大闸</h4><ul><li>依靠秒杀令牌的授权原理定制化发牌逻辑</li><li>根据秒杀商品初始库存颁发对应数量令牌，控制流量(n倍于库存)</li><li>用户风控和库存售罄判断前置到秒杀令牌发放中</li></ul><p><strong>存在问题</strong> 若商品量很大，瞬间涌入的流量仍然使系统无法应对；多库存，多商品等令牌限制能力弱（？？？）</p><h4 id="队列泄洪"><a href="#队列泄洪" class="headerlink" title="队列泄洪"></a>队列泄洪</h4><ul><li>排队有时比并发更加高效（如<a href="#redis">Redis单线程</a>，innodb mutex key等）</li><li>依靠排队限制并发流量</li><li>依靠排队和下游拥塞窗口程度调整队列释放流量大小</li></ul><p>设置拥塞窗口为n的等待队列(本地)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用线程池</span></span><br><span class="line">        Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 先加入库存流水init状态</span></span><br><span class="line">                String stockLogId = itemService.initStockLog(itemId,amount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 完成对应的下单事务性消息</span></span><br><span class="line">                <span class="keyword">if</span>(!mqProducer.transactionalAsyncReduceStock(userModel.getId(),promoId,itemId,amount,stockLogId)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.UNKNOWN_ERROR,<span class="string">"下单失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.UNKNOWN_ERROR,<span class="string">"哎呦，人太多啦！"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>分布式队列： 将队列设置到外部redis内。（有性能问题，如网络等）</p><blockquote><p>Q: Tomcat的多线程和线程池有什么关系？</p><p>A: <img src="https://segmentfault.com/img/bVbLHIc/view" alt="preview"></p></blockquote><h3 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h3><h4 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h4><h4 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h4><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>pre: 将商品详情单独作为itemModel，VO结合库存后发给前端</p><p>Nginx lua缓存当前商品详情页面。对于秒杀活动商品，失效时间较短，可以设置五秒；普通商品1分钟。</p><p>Guava Cache/Redis：</p><p>普通商品流程：商品详情采用Guava Cache-&gt;Redis缓存；库存直接打到Redis上，写操作使用Cache Aside Pattern保证双写一致性。为预防缓存击穿，使用<code>lock.tryLock()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getStockFromRedis(itemId)==<span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">      itemStock = itemService.getStockById(itemId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      itemStock = getStockFromRedis(itemId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (itemStock == <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秒杀商品在活动开始前将商品库存使用key为”promo_item_stock_”+itemId缓存商品库存，使用消息队列写库存。</p><p>此处应由前端根据itemVO判断商品是否处于秒杀阶段，从而调用秒杀下单/普通下单两套接口。为防止刷单，应在秒杀开始前将对应的普通商品下架。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugin测试</title>
      <link href="2021/04/26/tag-plugin%E6%B5%8B%E8%AF%95/"/>
      <url>2021/04/26/tag-plugin%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试一下各种小功能的使用。</p><a id="more"></a><blockquote><p>To be or not to be, that is a question. (BUG)</p><footer><strong>William Shakespear</strong><cite>Hamlet</cite></footer></blockquote><div class="alert alert-danger"><i class="fa fa-bug  float-left"></i>  <p>Spoiler content might cause discomfort.</p></div><div class="spoiler collapsed">    <div class="spoiler-title">        The Last of Us    </div>    <div class="spoiler-content">        <img src="https://i.ytimg.com/vi/vwzNbR0_gQA/maxresdefault.jpg" class="Joel dies" title="Abby killed Joel" alt="dont see for the benifit of yourself"><p class="text-success"></p><p>设置大小的时候不要加单位px，hexo这个文档写的真是没谁了……</p><p></p>    </div></div><a class="btn btn-primary" href="https://silverliningsl.github.io/about/">data</a> <!-- success, primary, info, warning, danger --><style>.bbplayer{width: 100%; max-width: 850px; margin: auto}</style><div class="bbplayer"><iframe class="bbplayer" id="mmedia-rJYdjUEzddupcYuD" src="https://player.bilibili.com/player.html?bvid=BV1m64y1m7QX&page=1&high_quality=1&danmaku=true" allowfullscreen="allowfullscreen" scrolling="no" border="0" frameborder="0" framespacing="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups"></iframe></div><script> document.getElementById("mmedia-rJYdjUEzddupcYuD").style.height=document.getElementById("mmedia-rJYdjUEzddupcYuD").scrollWidth*0.76+"px";    window.onresize = function(){      document.getElementById("mmedia-rJYdjUEzddupcYuD").style.height=document.getElementById("mmedia-rJYdjUEzddupcYuD").scrollWidth*0.76+"px";    }; </script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 随便搞搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GitHub分支对博客进行备份</title>
      <link href="2021/04/25/%E4%BD%BF%E7%94%A8GitHub%E5%88%86%E6%94%AF%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD/"/>
      <url>2021/04/25/%E4%BD%BF%E7%94%A8GitHub%E5%88%86%E6%94%AF%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>Hexo生成的静态页面被部署在远程仓库的gh-pages分支。为了方便以后在不同设备上快速部署，将源文件进行一个份的备。</p><a id="more"></a><h2 id="本地创建文件夹"><a href="#本地创建文件夹" class="headerlink" title="本地创建文件夹"></a>本地创建文件夹</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir hexo</span><br></pre></td></tr></table></figure><h2 id="Clone远程仓库至本地"><a href="#Clone远程仓库至本地" class="headerlink" title="Clone远程仓库至本地"></a>Clone远程仓库至本地</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/yourusername/yourusername.github.io hexo</span><br></pre></td></tr></table></figure><h2 id="把需要备份的文件复制至该文件夹"><a href="#把需要备份的文件复制至该文件夹" class="headerlink" title="把需要备份的文件复制至该文件夹"></a>把需要备份的文件复制至该文件夹</h2><p>主要有以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><blockquote><p>若使用git下载了主题，需将主题文件夹内的git文件删除(.git/, .gitingore)。</p></blockquote><h2 id="提交备份"><a href="#提交备份" class="headerlink" title="提交备份"></a>提交备份</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git add .  </span><br><span class="line"><span class="meta">$</span> git commit -m "创建备份" </span><br><span class="line"><span class="meta">$</span> git push --set-upstream origin main</span><br></pre></td></tr></table></figure><blockquote><p><code>--set-upstream origin main</code>的作用是<a href="https://stackoverflow.com/questions/18031946/what-does-set-upstream-do" target="_blank" rel="noopener">将本地分支<code>main</code>关联至远程仓库</a>。</p><p>那么<code>origin</code>的作用是什么呢？Google一下发现，<a href="https://stackoverflow.com/questions/11690709/can-a-project-have-multiple-origins" target="_blank" rel="noopener">一个git项目可以对应多个远程仓库</a>，只需添加remote：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>$ git remote add github https://github.com/Company_Name/repository_name.git</span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>到这里备份就完成了。需要在其他设备使用时，使用<code>git clone</code>将仓库克隆至本地，然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install hexo</span><br><span class="line"><span class="meta">$</span> npm install</span><br><span class="line"><span class="meta">$</span> npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>一键三连搭建环境即可。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 随便搞搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Resurrection</title>
      <link href="2021/04/24/Resurrection/"/>
      <url>2021/04/24/Resurrection/</url>
      
        <content type="html"><![CDATA[<p>Here I claim the site’s resurrection.</p><a id="more"></a><p>折腾了一晚上，把这个荒废了一年多的小站搞了搞，迁到了Github Pages。</p><p>远离社交媒体保平安，以后的生活尽量在这里记录了。</p><p>Salute!</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 自说自话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
